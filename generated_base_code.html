<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Generated Base Code</title>
  <style>body{font-family:Consolas,monospace;margin:24px;background:#f8fbff;color:#1f2937;}pre{white-space:pre-wrap;border:1px solid #d1d5db;padding:12px;background:#fff;}</style>
</head>
<body>
  <h1>Generated Base Code</h1>
  <pre>// Generated base code

// === FILE: .\Project\main.cpp ===
#include &lt;iostream&gt;

// Forward declaration of the syntactic broken AST runner
int run_syntactic_broken_ast(int argc, char *argv[]);

int main(int argc, char *argv[])
{
    return run_syntactic_broken_ast(argc, argv);
}


// === FILE: .\Project\Layer\Back system\syntacticBrokenAST.cpp ===
#include &quot;source_reader.hpp&quot;
#include &quot;algorithm_pipeline.hpp&quot;
#include &quot;cli_arguments.hpp&quot;
#include &quot;codebase_output_writer.hpp&quot;
#include &quot;lexical_structure_hooks.hpp&quot;
#include &quot;parse_tree.hpp&quot;
#include &quot;parse_tree_code_generator.hpp&quot;
#include &quot;parse_tree_symbols.hpp&quot;
#include &quot;creational_broken_tree.hpp&quot;
#include &quot;behavioural_broken_tree.hpp&quot;

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

namespace
{
bool write_text_file(const std::string&amp; path, const std::string&amp; content)
{
    std::ofstream out(path);
    if (!out)
    {
        return false;
    }
    out &lt;&lt; content;
    return true;
}
} // namespace

int run_syntactic_broken_ast(int argc, char* argv[])
{
    CliArguments cli;
    std::string cli_error;
    if (!parse_cli_arguments(argc, argv, cli, cli_error))
    {
        std::cerr &lt;&lt; cli_error &lt;&lt; &#39;\n&#39;;
        return 1;
    }

    const std::vector&lt;SourceFileUnit&gt; source_files = read_source_file_units(cli.input_files);
    if (source_files.empty())
    {
        std::cerr &lt;&lt; &quot;No source provided.\n&quot;;
        return 1;
    }

    const PipelineArtifacts artifacts =
        run_normalize_and_rewrite_pipeline(
            source_files,
            cli.source_pattern,
            cli.target_pattern,
            cli.input_files.size(),
            cli.input_files);
    const ParseTreeNode&amp; tree = artifacts.base_tree;
    const ParseTreeNode&amp; shadow_tree = artifacts.virtual_tree;

    std::cout &lt;&lt; &quot;\n=== C++ Parse Tree ===\n&quot;;
    std::cout &lt;&lt; parse_tree_to_text(tree);

    std::cout &lt;&lt; &quot;\n=== Shadow AST (Virtual Tree) ===\n&quot;;
    std::cout &lt;&lt; parse_tree_to_text(shadow_tree);

    const std::string parse_tree_output_path = &quot;parse_tree.html&quot;;
    if (!write_text_file(parse_tree_output_path, parse_tree_to_html(tree)))
    {
        std::cerr &lt;&lt; &quot;Failed to write &quot; &lt;&lt; parse_tree_output_path &lt;&lt; &#39;\n&#39;;
        return 1;
    }

    const CreationalTreeNode&amp; creational_tree = artifacts.creational_tree;

    std::cout &lt;&lt; &quot;\n=== Creational Broken Tree ===\n&quot;;
    std::cout &lt;&lt; creational_tree_to_text(creational_tree);

    const std::string creational_output_path = &quot;creational_parse_tree.html&quot;;
    if (!write_text_file(creational_output_path, creational_tree_to_html(creational_tree)))
    {
        std::cerr &lt;&lt; &quot;Failed to write &quot; &lt;&lt; creational_output_path &lt;&lt; &#39;\n&#39;;
        return 1;
    }

    const ParseTreeNode&amp; behavioural_tree = artifacts.behavioural_tree;

    std::cout &lt;&lt; &quot;\n=== Behavioural Broken Tree ===\n&quot;;
    std::cout &lt;&lt; parse_tree_to_text(behavioural_tree);

    const std::string behavioural_output_path = &quot;behavioural_broken_ast.html&quot;;
    if (!write_text_file(behavioural_output_path, behavioural_broken_tree_to_html(behavioural_tree)))
    {
        std::cerr &lt;&lt; &quot;Failed to write &quot; &lt;&lt; behavioural_output_path &lt;&lt; &#39;\n&#39;;
        return 1;
    }

    std::cout &lt;&lt; &quot;\nHTML parse tree generated: &quot; &lt;&lt; parse_tree_output_path &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Creational HTML generated: &quot; &lt;&lt; creational_output_path &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Behavioural HTML generated: &quot; &lt;&lt; behavioural_output_path &lt;&lt; &#39;\n&#39;;

    const std::string merged_source = join_source_file_units(source_files);
    const std::string base_code = generate_base_code_from_source(merged_source);
    const std::string target_code =
        generate_target_code_from_source(merged_source, cli.source_pattern, cli.target_pattern);

    std::cout &lt;&lt; &quot;\n=== Generated Base Code ===\n&quot;;
    std::cout &lt;&lt; base_code &lt;&lt; &#39;\n&#39;;

    CodebaseOutputPaths code_paths;
    if (!write_codebase_outputs(base_code, target_code, cli.target_pattern, code_paths))
    {
        std::cerr &lt;&lt; &quot;Failed to write generated base/target code outputs.\n&quot;;
        return 1;
    }

    std::cout &lt;&lt; &quot;Generated base code cpp: &quot; &lt;&lt; code_paths.base_cpp_path &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Generated target code cpp: &quot; &lt;&lt; code_paths.target_cpp_path &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Generated base code html: &quot; &lt;&lt; code_paths.base_html_path &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Generated target code html: &quot; &lt;&lt; code_paths.target_html_path &lt;&lt; &#39;\n&#39;;

    std::cout &lt;&lt; &quot;\n=== Performance Report ===\n&quot;;
    std::cout &lt;&lt; &quot;Source pattern: &quot; &lt;&lt; artifacts.report.source_pattern &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Target pattern: &quot; &lt;&lt; artifacts.report.target_pattern &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Input files: &quot; &lt;&lt; artifacts.report.input_file_count &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Total elapsed (ms): &quot; &lt;&lt; artifacts.report.total_elapsed_ms &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Peak estimated memory (bytes): &quot; &lt;&lt; artifacts.report.peak_estimated_bytes &lt;&lt; &#39;\n&#39;;
    std::cout &lt;&lt; &quot;Graph consistent: &quot; &lt;&lt; (artifacts.report.graph_consistent ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &#39;\n&#39;;
    for (const StageMetric&amp; s : artifacts.report.stages)
    {
        std::cout &lt;&lt; &quot; - &quot; &lt;&lt; s.name
                  &lt;&lt; &quot; | elapsed_ms=&quot; &lt;&lt; s.elapsed_ms
                  &lt;&lt; &quot; | estimated_bytes=&quot; &lt;&lt; s.estimated_bytes &lt;&lt; &#39;\n&#39;;
    }

    std::cout &lt;&lt; &quot;\n=== Class Usage Hashes ===\n&quot;;
    std::cout &lt;&lt; &quot;Crucial classes selected by strategy:\n&quot;;
    for (const CrucialClassInfo&amp; info : get_crucial_class_registry())
    {
        std::cout &lt;&lt; &quot; - class=&quot; &lt;&lt; info.name
                  &lt;&lt; &quot; | class_name_hash=&quot; &lt;&lt; info.class_name_hash
                  &lt;&lt; &quot; | strategy=&quot; &lt;&lt; info.strategy_name &lt;&lt; &#39;\n&#39;;
    }

    for (const ParseSymbol&amp; cls : getClassSymbolTable())
    {
        std::cout &lt;&lt; &quot; - class_def=&quot; &lt;&lt; cls.name
                  &lt;&lt; &quot; | class_name_hash=&quot; &lt;&lt; cls.name_hash
                  &lt;&lt; &quot; | contextual_hash=&quot; &lt;&lt; cls.contextual_hash
                  &lt;&lt; &quot; | scoped_hash=&quot; &lt;&lt; cls.hash_value
                  &lt;&lt; &quot; | definition_node_index=&quot; &lt;&lt; cls.definition_node_index &lt;&lt; &#39;\n&#39;;
    }
    for (const ParseSymbolUsage&amp; usage : getClassUsageTable())
    {
        std::cout &lt;&lt; &quot; - class=&quot; &lt;&lt; usage.name
                  &lt;&lt; &quot; | type=&quot; &lt;&lt; usage.type_string
                  &lt;&lt; &quot; | node_index=&quot; &lt;&lt; usage.node_index
                  &lt;&lt; &quot; | node_contextual_hash=&quot; &lt;&lt; usage.node_contextual_hash
                  &lt;&lt; &quot; | class_name_hash=&quot; &lt;&lt; usage.class_name_hash
                  &lt;&lt; &quot; | scoped_usage_hash=&quot; &lt;&lt; usage.hash_value
                  &lt;&lt; &quot; | hash_collision=&quot; &lt;&lt; (usage.hash_collision ? &quot;true&quot; : &quot;false&quot;)
                  &lt;&lt; &quot; | refactor_candidate=&quot; &lt;&lt; (usage.refactor_candidate ? &quot;true&quot; : &quot;false&quot;)
                  &lt;&lt; &quot; | node_kind=&quot; &lt;&lt; usage.node_kind &lt;&lt; &#39;\n&#39;;
    }

    std::cout &lt;&lt; &quot;\n=== Line Hash Traces ===\n&quot;;
    for (const LineHashTrace&amp; trace : get_line_hash_traces())
    {
        std::cout &lt;&lt; &quot; - line=&quot; &lt;&lt; trace.line_number
                  &lt;&lt; &quot; | class=&quot; &lt;&lt; trace.class_name
                  &lt;&lt; &quot; | class_hash=&quot; &lt;&lt; trace.class_name_hash
                  &lt;&lt; &quot; | hit_token_index=&quot; &lt;&lt; trace.hit_token_index
                  &lt;&lt; &quot; | outgoing_hash=&quot; &lt;&lt; trace.outgoing_hash
                  &lt;&lt; &quot; | dirty_tokens=&quot; &lt;&lt; trace.dirty_token_count
                  &lt;&lt; &quot; | collision=&quot; &lt;&lt; (trace.hash_collision ? &quot;true&quot; : &quot;false&quot;)
                  &lt;&lt; &#39;\n&#39;;
    }

    const std::string report_output_path = &quot;analysis_report.json&quot;;
    if (!write_text_file(report_output_path, pipeline_report_to_json(artifacts.report)))
    {
        std::cerr &lt;&lt; &quot;Failed to write &quot; &lt;&lt; report_output_path &lt;&lt; &#39;\n&#39;;
        return 1;
    }
    std::cout &lt;&lt; &quot;Performance JSON report generated: &quot; &lt;&lt; report_output_path &lt;&lt; &#39;\n&#39;;

    return 0;
}


// === FILE: .\Project\Modules\Source\Behavioural\behavioural_broken_tree.cpp ===
#include &quot;behavioural_broken_tree.hpp&quot;

#include &quot;Logic/behavioural_logic_scaffold.hpp&quot;
#include &quot;tree_html_renderer.hpp&quot;

ParseTreeNode build_behavioural_broken_tree(const ParseTreeNode&amp; parse_root)
{
    return build_behavioural_function_scaffold(parse_root);
}

std::string behavioural_broken_tree_to_html(const ParseTreeNode&amp; root)
{
    return render_tree_html(root, &quot;Behavioural Broken AST&quot;, &quot;No function symbols found.&quot;);
}


// === FILE: .\Project\Modules\Source\Behavioural\behavioural_symbol_test.cpp ===
#include &quot;behavioural_symbol_test.hpp&quot;

#include &quot;parse_tree_symbols.hpp&quot;

#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

ParseTreeNode build_behavioural_symbol_test_tree(const ParseTreeNode&amp; parse_root)
{
    rebuild_parse_tree_symbol_tables(parse_root);

    ParseTreeNode root{&quot;BehaviouralSymbolTestRoot&quot;, &quot;function symbols as siblings&quot;, {}};

    const std::vector&lt;ParseSymbol&gt;&amp; functions = getFunctionSymbolTable();
    for (const ParseSymbol&amp; fn : functions)
    {
        const ParseSymbol* lookup = getFunctionByName(fn.name);
        const size_t expected_hash = std::hash&lt;std::string&gt;{}(fn.name);

        ParseTreeNode child;
        child.kind = &quot;FunctionSymbol&quot;;
        child.value = fn.name +
            &quot; | name_hash_ok=&quot; + (fn.name_hash == expected_hash ? std::string(&quot;true&quot;) : std::string(&quot;false&quot;)) +
            &quot; | contextual_hash=&quot; + std::to_string(fn.contextual_hash) +
            &quot; | lookup_ok=&quot; + ((lookup != nullptr) ? std::string(&quot;true&quot;) : std::string(&quot;false&quot;));

        root.children.push_back(std::move(child));
    }

    return root;
}

std::string behavioural_symbol_test_to_text(const ParseTreeNode&amp; root)
{
    std::ostringstream out;

    std::function&lt;void(const ParseTreeNode&amp;, int)&gt; walk = [&amp;](const ParseTreeNode&amp; node, int depth) {
        out &lt;&lt; std::string(static_cast&lt;size_t&gt;(depth) * 2, &#39; &#39;) &lt;&lt; node.kind;
        if (!node.value.empty())
        {
            out &lt;&lt; &quot;: &quot; &lt;&lt; node.value;
        }
        out &lt;&lt; &#39;\n&#39;;

        for (const ParseTreeNode&amp; child : node.children)
        {
            walk(child, depth + 1);
        }
    };

    walk(root, 0);
    return out.str();
}


// === FILE: .\Project\Modules\Source\Behavioural\Logic\behavioural_logic_scaffold.cpp ===
#include &quot;Logic/behavioural_logic_scaffold.hpp&quot;

#include &quot;parse_tree_dependency_utils.hpp&quot;
#include &quot;language_tokens.hpp&quot;

#include &lt;string&gt;
#include &lt;utility&gt;

ParseTreeNode build_behavioural_function_scaffold(const ParseTreeNode&amp; parse_root)
{
    ParseTreeNode root{&quot;BehaviouralEntryRoot&quot;, &quot;function traversal scaffold&quot;, {}};
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);

    const std::vector&lt;DependencySymbolNode&gt; functions = collect_dependency_function_nodes(parse_root);
    for (const DependencySymbolNode&amp; fn : functions)
    {
        const std::string lowered = lowercase_ascii(fn.name);
        if (cfg.function_exclusion_keywords.find(lowered) != cfg.function_exclusion_keywords.end())
        {
            continue;
        }

        ParseTreeNode fn_node;
        fn_node.kind = &quot;FunctionNode&quot;;
        fn_node.value = fn.name;
        root.children.push_back(std::move(fn_node));
    }

    return root;
}


// === FILE: .\Project\Modules\Source\Creational\creational_broken_tree.cpp ===
#include &quot;creational_broken_tree.hpp&quot;
#include &quot;Factory/factory_pattern_logic.hpp&quot;
#include &quot;Singleton/singleton_pattern_logic.hpp&quot;
#include &quot;tree_html_renderer.hpp&quot;

#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

CreationalTreeNode build_creational_broken_tree(const ParseTreeNode&amp; root)
{
    CreationalTreeNode out{&quot;CreationalPatternsRoot&quot;, &quot;factory + singleton&quot;, {}};

    CreationalTreeNode factory_tree = build_factory_pattern_tree(root);
    if (!factory_tree.children.empty())
    {
        out.children.push_back(std::move(factory_tree));
    }

    CreationalTreeNode singleton_tree = build_singleton_pattern_tree(root);
    if (!singleton_tree.children.empty())
    {
        out.children.push_back(std::move(singleton_tree));
    }

    if (out.children.empty())
    {
        out.label = &quot;NoFactoryOrSingletonPatternFound&quot;;
    }

    return out;
}

ParseTreeNode creational_tree_to_parse_tree_node(const CreationalTreeNode&amp; root)
{
    ParseTreeNode out;
    out.kind = root.kind;
    out.value = root.label;

    for (const CreationalTreeNode&amp; child : root.children)
    {
        out.children.push_back(creational_tree_to_parse_tree_node(child));
    }

    return out;
}

std::string creational_tree_to_html(const CreationalTreeNode&amp; root)
{
    const ParseTreeNode parse_root = creational_tree_to_parse_tree_node(root);
    return render_tree_html(
        parse_root,
        &quot;Creational Broken Tree&quot;,
        &quot;No creational (factory/singleton) pattern found in this source.&quot;);
}

std::string creational_tree_to_text(const CreationalTreeNode&amp; root)
{
    std::ostringstream out;

    std::function&lt;void(const CreationalTreeNode&amp;, int)&gt; walk = [&amp;](const CreationalTreeNode&amp; node, int depth) {
        out &lt;&lt; std::string(static_cast&lt;size_t&gt;(depth) * 2, &#39; &#39;) &lt;&lt; node.kind;
        if (!node.label.empty())
        {
            out &lt;&lt; &quot;: &quot; &lt;&lt; node.label;
        }
        out &lt;&lt; &#39;\n&#39;;

        for (const CreationalTreeNode&amp; child : node.children)
        {
            walk(child, depth + 1);
        }
    };

    walk(root, 0);
    return out.str();
}


// === FILE: .\Project\Modules\Source\Creational\creational_symbol_test.cpp ===
#include &quot;creational_symbol_test.hpp&quot;

#include &quot;parse_tree_symbols.hpp&quot;

#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

ParseTreeNode build_creational_symbol_test_tree(const ParseTreeNode&amp; parse_root)
{
    rebuild_parse_tree_symbol_tables(parse_root);

    ParseTreeNode root{&quot;CreationalSymbolTestRoot&quot;, &quot;class symbols as siblings&quot;, {}};

    const std::vector&lt;ParseSymbol&gt;&amp; classes = getClassSymbolTable();
    for (const ParseSymbol&amp; cls : classes)
    {
        const ParseSymbol* lookup = getClassByName(cls.name);
        const size_t expected_hash = std::hash&lt;std::string&gt;{}(cls.name);

        ParseTreeNode child;
        child.kind = &quot;ClassSymbol&quot;;
        child.value = cls.name +
            &quot; | name_hash_ok=&quot; + (cls.name_hash == expected_hash ? std::string(&quot;true&quot;) : std::string(&quot;false&quot;)) +
            &quot; | contextual_hash=&quot; + std::to_string(cls.contextual_hash) +
            &quot; | lookup_ok=&quot; + ((lookup != nullptr) ? std::string(&quot;true&quot;) : std::string(&quot;false&quot;));

        root.children.push_back(std::move(child));
    }

    return root;
}

std::string creational_symbol_test_to_text(const ParseTreeNode&amp; root)
{
    std::ostringstream out;

    std::function&lt;void(const ParseTreeNode&amp;, int)&gt; walk = [&amp;](const ParseTreeNode&amp; node, int depth) {
        out &lt;&lt; std::string(static_cast&lt;size_t&gt;(depth) * 2, &#39; &#39;) &lt;&lt; node.kind;
        if (!node.value.empty())
        {
            out &lt;&lt; &quot;: &quot; &lt;&lt; node.value;
        }
        out &lt;&lt; &#39;\n&#39;;

        for (const ParseTreeNode&amp; child : node.children)
        {
            walk(child, depth + 1);
        }
    };

    walk(root, 0);
    return out.str();
}


// === FILE: .\Project\Modules\Source\Creational\Builder\builder_pattern_logic.cpp ===
#include &quot;Builder/builder_pattern_logic.hpp&quot;

#include &quot;language_tokens.hpp&quot;

#include &lt;cctype&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace
{
std::string trim(const std::string&amp; input)
{
    size_t begin = 0;
    while (begin &lt; input.size() &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[begin])))
    {
        ++begin;
    }

    size_t end = input.size();
    while (end &gt; begin &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[end - 1])))
    {
        --end;
    }

    return input.substr(begin, end - begin);
}

std::vector&lt;std::string&gt; split_words(const std::string&amp; text)
{
    std::vector&lt;std::string&gt; words;
    std::string current;
    for (char c : text)
    {
        if (std::isalnum(static_cast&lt;unsigned char&gt;(c)) || c == &#39;_&#39;)
        {
            current.push_back(c);
        }
        else if (!current.empty())
        {
            words.push_back(current);
            current.clear();
        }
    }
    if (!current.empty())
    {
        words.push_back(current);
    }
    return words;
}

std::string lower(const std::string&amp; s)
{
    return lowercase_ascii(s);
}

bool starts_with(const std::string&amp; s, const std::string&amp; p)
{
    return s.size() &gt;= p.size() &amp;&amp; s.compare(0, p.size(), p) == 0;
}

bool is_class_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }
    const std::string v = lower(trim(node.value));
    return starts_with(v, &quot;class &quot;) || starts_with(v, &quot;struct &quot;);
}

bool is_function_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string sig = trim(node.value);
    if (sig.empty() || sig.find(&#39;(&#39;) == std::string::npos || sig.find(&#39;)&#39;) == std::string::npos)
    {
        return false;
    }

    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; words = split_words(sig);
    if (words.empty())
    {
        return false;
    }
    return cfg.function_exclusion_keywords.find(lower(words.front())) == cfg.function_exclusion_keywords.end();
}

std::string class_name(const std::string&amp; sig)
{
    const std::vector&lt;std::string&gt; words = split_words(sig);
    for (size_t i = 0; i + 1 &lt; words.size(); ++i)
    {
        const std::string kw = lower(words[i]);
        if (kw == &quot;class&quot; || kw == &quot;struct&quot;)
        {
            return words[i + 1];
        }
    }
    return {};
}

std::string function_name(const std::string&amp; sig)
{
    const std::string t = trim(sig);
    const size_t open = t.find(&#39;(&#39;);
    if (open == std::string::npos)
    {
        return {};
    }
    const std::vector&lt;std::string&gt; words = split_words(t.substr(0, open));
    if (words.empty())
    {
        return {};
    }
    return words.back();
}

bool has_builder_assignments(const ParseTreeNode&amp; fn)
{
    for (const ParseTreeNode&amp; n : fn.children)
    {
        if (n.kind == &quot;AssignmentOrVarDecl&quot; || n.kind == &quot;MemberAssignment&quot;)
        {
            return true;
        }
    }
    return false;
}
} // namespace

CreationalTreeNode build_builder_pattern_tree(const ParseTreeNode&amp; parse_root)
{
    CreationalTreeNode root{&quot;BuilderPatternRoot&quot;, &quot;class with multiple assignment-oriented methods&quot;, {}};

    std::vector&lt;const ParseTreeNode*&gt; stack{&amp;parse_root};
    while (!stack.empty())
    {
        const ParseTreeNode* node = stack.back();
        stack.pop_back();

        if (is_class_block(*node))
        {
            CreationalTreeNode cls{&quot;ClassNode&quot;, class_name(node-&gt;value), {}};

            int qualifying_fn_count = 0;
            for (const ParseTreeNode&amp; fn : node-&gt;children)
            {
                if (!is_function_block(fn))
                {
                    continue;
                }
                if (!has_builder_assignments(fn))
                {
                    continue;
                }

                ++qualifying_fn_count;
                cls.children.push_back(CreationalTreeNode{&quot;BuilderMethod&quot;, function_name(fn.value), {}});
            }

            if (qualifying_fn_count &gt;= 2)
            {
                root.children.push_back(std::move(cls));
            }
        }

        for (const ParseTreeNode&amp; child : node-&gt;children)
        {
            stack.push_back(&amp;child);
        }
    }

    return root;
}


// === FILE: .\Project\Modules\Source\Creational\Factory\factory_pattern_logic.cpp ===
#include &quot;Factory/factory_pattern_logic.hpp&quot;

#include &quot;language_tokens.hpp&quot;
#include &quot;parse_tree_symbols.hpp&quot;

#include &lt;cctype&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace
{
std::string trim(const std::string&amp; input)
{
    size_t begin = 0;
    while (begin &lt; input.size() &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[begin])))
    {
        ++begin;
    }

    size_t end = input.size();
    while (end &gt; begin &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[end - 1])))
    {
        --end;
    }

    return input.substr(begin, end - begin);
}

std::string to_lower(const std::string&amp; value)
{
    return lowercase_ascii(value);
}

std::vector&lt;std::string&gt; split_words(const std::string&amp; text)
{
    std::vector&lt;std::string&gt; words;
    std::string current;

    for (char c : text)
    {
        if (std::isalnum(static_cast&lt;unsigned char&gt;(c)) || c == &#39;_&#39;)
        {
            current.push_back(c);
        }
        else if (!current.empty())
        {
            words.push_back(current);
            current.clear();
        }
    }

    if (!current.empty())
    {
        words.push_back(current);
    }

    return words;
}

bool starts_with(const std::string&amp; text, const std::string&amp; prefix)
{
    return text.size() &gt;= prefix.size() &amp;&amp; text.compare(0, prefix.size(), prefix) == 0;
}

std::string class_name_from_signature(const std::string&amp; signature)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; words = split_words(signature);
    for (size_t i = 0; i + 1 &lt; words.size(); ++i)
    {
        if (cfg.class_keywords.find(to_lower(words[i])) != cfg.class_keywords.end())
        {
            return words[i + 1];
        }
    }
    return {};
}

std::string function_name_from_signature(const std::string&amp; signature)
{
    const std::string trimmed = trim(signature);
    const size_t open = trimmed.find(&#39;(&#39;);
    if (open == std::string::npos)
    {
        return {};
    }

    const std::vector&lt;std::string&gt; words = split_words(trimmed.substr(0, open));
    if (words.empty())
    {
        return {};
    }

    return words.back();
}

bool is_class_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string lowered = to_lower(trim(node.value));
    return starts_with(lowered, &quot;class &quot;) || starts_with(lowered, &quot;struct &quot;);
}

bool is_function_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string signature = trim(node.value);
    if (signature.empty() || signature.find(&#39;(&#39;) == std::string::npos || signature.find(&#39;)&#39;) == std::string::npos)
    {
        return false;
    }

    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; words = split_words(signature);
    if (words.empty())
    {
        return false;
    }

    const std::string first = to_lower(words.front());
    return cfg.function_exclusion_keywords.find(first) == cfg.function_exclusion_keywords.end();
}

bool is_conditional_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string lowered = to_lower(trim(node.value));
    return starts_with(lowered, &quot;if&quot;) || starts_with(lowered, &quot;else if&quot;) || starts_with(lowered, &quot;switch&quot;);
}

std::string extract_return_expr(const std::string&amp; value)
{
    std::string expr = trim(value);
    const std::string lowered = to_lower(expr);
    if (starts_with(lowered, &quot;return&quot;))
    {
        expr = trim(expr.substr(6));
    }
    return expr;
}

std::string extract_type_in_angle_brackets(const std::string&amp; expr)
{
    const size_t l = expr.find(&#39;&lt;&#39;);
    const size_t r = expr.find(&#39;&gt;&#39;, l == std::string::npos ? 0 : l + 1);
    if (l == std::string::npos || r == std::string::npos || r &lt;= l + 1)
    {
        return {};
    }
    return trim(expr.substr(l + 1, r - l - 1));
}

std::string remove_spaces(const std::string&amp; input)
{
    std::string out;
    out.reserve(input.size());
    for (char c : input)
    {
        if (!std::isspace(static_cast&lt;unsigned char&gt;(c)))
        {
            out.push_back(c);
        }
    }
    return out;
}

bool is_factory_allocator_return(const std::string&amp; return_expr, std::string&amp; out_matched_class)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::string lowered = to_lower(trim(return_expr));
    const std::string lowered_no_space = remove_spaces(lowered);

    if (starts_with(lowered, &quot;new &quot;))
    {
        const std::vector&lt;std::string&gt; words = split_words(return_expr.substr(4));
        if (!words.empty() &amp;&amp; getClassByName(words.front()) != nullptr)
        {
            out_matched_class = words.front();
            return true;
        }
        return false;
    }

    for (const std::string&amp; allocator : cfg.allocator_template_functions)
    {
        if (lowered_no_space.find(allocator + &quot;&lt;&quot;) != std::string::npos)
        {
            const std::string class_candidate = extract_type_in_angle_brackets(return_expr);
            if (!class_candidate.empty() &amp;&amp; getClassByName(class_candidate) != nullptr)
            {
                out_matched_class = class_candidate;
                return true;
            }
        }
    }

    return false;
}
} // namespace

CreationalTreeNode build_factory_pattern_tree(const ParseTreeNode&amp; parse_root)
{
    rebuild_parse_tree_symbol_tables(parse_root);

    CreationalTreeNode root{&quot;FactoryPatternRoot&quot;, &quot;class/function/conditional/allocator-return&quot;, {}};

    std::vector&lt;const ParseTreeNode*&gt; class_blocks;
    std::vector&lt;const ParseTreeNode*&gt; stack{&amp;parse_root};
    while (!stack.empty())
    {
        const ParseTreeNode* node = stack.back();
        stack.pop_back();
        if (is_class_block(*node))
        {
            class_blocks.push_back(node);
        }
        for (const ParseTreeNode&amp; child : node-&gt;children)
        {
            stack.push_back(&amp;child);
        }
    }

    for (const ParseTreeNode* cls : class_blocks)
    {
        CreationalTreeNode class_node{&quot;ClassNode&quot;, class_name_from_signature(cls-&gt;value), {}};

        for (const ParseTreeNode&amp; fn : cls-&gt;children)
        {
            if (!is_function_block(fn))
            {
                continue;
            }

            CreationalTreeNode fn_node{&quot;FunctionNode&quot;, function_name_from_signature(fn.value), {}};

            for (const ParseTreeNode&amp; cond : fn.children)
            {
                if (!is_conditional_block(cond))
                {
                    continue;
                }

                CreationalTreeNode cond_node{&quot;ConditionalNode&quot;, trim(cond.value), {}};

                for (const ParseTreeNode&amp; inner : cond.children)
                {
                    if (inner.kind != &quot;ReturnStatement&quot;)
                    {
                        continue;
                    }

                    const std::string expr = extract_return_expr(inner.value);
                    std::string matched_class;
                    if (is_factory_allocator_return(expr, matched_class))
                    {
                        cond_node.children.push_back(
                            CreationalTreeNode{&quot;AllocatorReturn&quot;, expr + &quot; | class=&quot; + matched_class, {}});
                    }
                }

                if (!cond_node.children.empty())
                {
                    fn_node.children.push_back(std::move(cond_node));
                }
            }

            if (!fn_node.children.empty())
            {
                class_node.children.push_back(std::move(fn_node));
            }
        }

        if (!class_node.children.empty())
        {
            root.children.push_back(std::move(class_node));
        }
    }

    return root;
}


// === FILE: .\Project\Modules\Source\Creational\Logic\creational_logic_scaffold.cpp ===
#include &quot;Logic/creational_logic_scaffold.hpp&quot;

#include &quot;parse_tree_dependency_utils.hpp&quot;

#include &lt;string&gt;
#include &lt;utility&gt;

CreationalTreeNode build_creational_class_scaffold(const ParseTreeNode&amp; parse_root)
{
    CreationalTreeNode root{&quot;CreationalEntryRoot&quot;, &quot;class traversal scaffold&quot;, {}};

    const std::vector&lt;DependencySymbolNode&gt; classes = collect_dependency_class_nodes(parse_root);
    for (const DependencySymbolNode&amp; cls : classes)
    {
        CreationalTreeNode class_node;
        class_node.kind = &quot;ClassNode&quot;;
        class_node.label = cls.name + &quot; | hash=&quot; + std::to_string(cls.hash_value);
        root.children.push_back(std::move(class_node));
    }

    return root;
}


// === FILE: .\Project\Modules\Source\Creational\Singleton\singleton_pattern_logic.cpp ===
#include &quot;Singleton/singleton_pattern_logic.hpp&quot;

#include &quot;language_tokens.hpp&quot;

#include &lt;cctype&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

namespace
{
std::string trim(const std::string&amp; input)
{
    size_t begin = 0;
    while (begin &lt; input.size() &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[begin])))
    {
        ++begin;
    }

    size_t end = input.size();
    while (end &gt; begin &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[end - 1])))
    {
        --end;
    }

    return input.substr(begin, end - begin);
}

std::string to_lower(const std::string&amp; value)
{
    return lowercase_ascii(value);
}

bool starts_with(const std::string&amp; text, const std::string&amp; prefix)
{
    return text.size() &gt;= prefix.size() &amp;&amp; text.compare(0, prefix.size(), prefix) == 0;
}

std::vector&lt;std::string&gt; split_words(const std::string&amp; text)
{
    std::vector&lt;std::string&gt; words;
    std::string current;

    for (char c : text)
    {
        if (std::isalnum(static_cast&lt;unsigned char&gt;(c)) || c == &#39;_&#39;)
        {
            current.push_back(c);
        }
        else if (!current.empty())
        {
            words.push_back(current);
            current.clear();
        }
    }

    if (!current.empty())
    {
        words.push_back(current);
    }

    return words;
}

std::string class_name_from_signature(const std::string&amp; signature)
{
    const std::vector&lt;std::string&gt; words = split_words(signature);
    for (size_t i = 0; i + 1 &lt; words.size(); ++i)
    {
        const std::string kw = to_lower(words[i]);
        if (kw == &quot;class&quot; || kw == &quot;struct&quot;)
        {
            return words[i + 1];
        }
    }
    return {};
}

std::string function_name_from_signature(const std::string&amp; signature)
{
    const std::string trimmed = trim(signature);
    const size_t open = trimmed.find(&#39;(&#39;);
    if (open == std::string::npos)
    {
        return {};
    }

    const std::vector&lt;std::string&gt; words = split_words(trimmed.substr(0, open));
    if (words.empty())
    {
        return {};
    }

    return words.back();
}

bool is_class_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string lowered = to_lower(trim(node.value));
    return starts_with(lowered, &quot;class &quot;) || starts_with(lowered, &quot;struct &quot;);
}

bool is_function_block(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string signature = trim(node.value);
    if (signature.empty() || signature.find(&#39;(&#39;) == std::string::npos || signature.find(&#39;)&#39;) == std::string::npos)
    {
        return false;
    }

    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; words = split_words(signature);
    if (words.empty())
    {
        return false;
    }

    const std::string first = to_lower(words.front());
    return cfg.function_exclusion_keywords.find(first) == cfg.function_exclusion_keywords.end();
}

std::string extract_return_identifier(const ParseTreeNode&amp; node)
{
    if (node.kind != &quot;ReturnStatement&quot;)
    {
        return {};
    }

    std::string expr = trim(node.value);
    const std::string lowered = to_lower(expr);
    if (starts_with(lowered, &quot;return&quot;))
    {
        expr = trim(expr.substr(6));
    }

    const std::vector&lt;std::string&gt; words = split_words(expr);
    if (words.empty())
    {
        return {};
    }

    return words.front();
}

bool find_static_same_class_identifier(const ParseTreeNode&amp; fn_node, const std::string&amp; class_name, std::string&amp; out_identifier)
{
    std::vector&lt;const ParseTreeNode*&gt; stack{&amp;fn_node};
    while (!stack.empty())
    {
        const ParseTreeNode* node = stack.back();
        stack.pop_back();

        if (node-&gt;kind == &quot;Statement&quot; || node-&gt;kind == &quot;AssignmentOrVarDecl&quot;)
        {
            const std::vector&lt;std::string&gt; words = split_words(node-&gt;value);
            for (size_t i = 0; i + 2 &lt; words.size(); ++i)
            {
                if (to_lower(words[i]) == &quot;static&quot; &amp;&amp; words[i + 1] == class_name)
                {
                    out_identifier = words[i + 2];
                    return true;
                }
            }
        }

        for (const ParseTreeNode&amp; child : node-&gt;children)
        {
            stack.push_back(&amp;child);
        }
    }

    return false;
}

bool function_returns_identifier(const ParseTreeNode&amp; fn_node, const std::string&amp; identifier)
{
    std::vector&lt;const ParseTreeNode*&gt; stack{&amp;fn_node};
    while (!stack.empty())
    {
        const ParseTreeNode* node = stack.back();
        stack.pop_back();

        const std::string ret_id = extract_return_identifier(*node);
        if (!ret_id.empty() &amp;&amp; ret_id == identifier)
        {
            return true;
        }

        for (const ParseTreeNode&amp; child : node-&gt;children)
        {
            stack.push_back(&amp;child);
        }
    }

    return false;
}
} // namespace

CreationalTreeNode build_singleton_pattern_tree(const ParseTreeNode&amp; parse_root)
{
    CreationalTreeNode root{&quot;SingletonPatternRoot&quot;, &quot;static same-class instance + return identifier&quot;, {}};

    std::vector&lt;const ParseTreeNode*&gt; stack{&amp;parse_root};
    while (!stack.empty())
    {
        const ParseTreeNode* node = stack.back();
        stack.pop_back();

        if (is_class_block(*node))
        {
            const std::string cls_name = class_name_from_signature(node-&gt;value);
            if (cls_name.empty())
            {
                continue;
            }

            CreationalTreeNode cls_node{&quot;ClassNode&quot;, cls_name, {}};

            for (const ParseTreeNode&amp; fn : node-&gt;children)
            {
                if (!is_function_block(fn))
                {
                    continue;
                }

                std::string static_identifier;
                if (!find_static_same_class_identifier(fn, cls_name, static_identifier))
                {
                    continue;
                }

                if (!function_returns_identifier(fn, static_identifier))
                {
                    continue;
                }

                CreationalTreeNode fn_node{&quot;SingletonFunction&quot;, function_name_from_signature(fn.value), {}};
                fn_node.children.push_back(CreationalTreeNode{
                    &quot;StaticInstanceDecl&quot;,
                    &quot;static &quot; + cls_name + &quot; &quot; + static_identifier,
                    {}});
                fn_node.children.push_back(CreationalTreeNode{
                    &quot;ReturnIdentifier&quot;,
                    static_identifier,
                    {}});

                cls_node.children.push_back(std::move(fn_node));
            }

            if (!cls_node.children.empty())
            {
                root.children.push_back(std::move(cls_node));
            }
        }

        for (const ParseTreeNode&amp; child : node-&gt;children)
        {
            stack.push_back(&amp;child);
        }
    }

    return root;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\algorithm_pipeline.cpp ===
#include &quot;algorithm_pipeline.hpp&quot;

#include &quot;parse_tree_symbols.hpp&quot;

#include &lt;algorithm&gt;
#include &lt;chrono&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

namespace
{
using Clock = std::chrono::steady_clock;

size_t estimate_parse_tree_bytes(const ParseTreeNode&amp; node)
{
    size_t total = sizeof(ParseTreeNode) + node.kind.size() + node.value.size();
    total += node.children.capacity() * sizeof(ParseTreeNode);

    for (const ParseTreeNode&amp; child : node.children)
    {
        total += estimate_parse_tree_bytes(child);
    }

    return total;
}

size_t estimate_creational_tree_bytes(const CreationalTreeNode&amp; node)
{
    size_t total = sizeof(CreationalTreeNode) + node.kind.size() + node.label.size();
    total += node.children.capacity() * sizeof(CreationalTreeNode);

    for (const CreationalTreeNode&amp; child : node.children)
    {
        total += estimate_creational_tree_bytes(child);
    }

    return total;
}

size_t estimate_symbol_table_bytes()
{
    size_t total = 0;

    const std::vector&lt;ParseSymbol&gt;&amp; classes = getClassSymbolTable();
    const std::vector&lt;ParseSymbol&gt;&amp; functions = getFunctionSymbolTable();

    total += classes.capacity() * sizeof(ParseSymbol);
    total += functions.capacity() * sizeof(ParseSymbol);

    for (const ParseSymbol&amp; s : classes)
    {
        total += s.name.size() + s.signature.size();
    }
    for (const ParseSymbol&amp; s : functions)
    {
        total += s.name.size() + s.signature.size();
    }

    return total;
}

std::string json_escape(const std::string&amp; input)
{
    std::string out;
    out.reserve(input.size());
    for (char c : input)
    {
        switch (c)
        {
            case &#39;\\&#39;: out += &quot;\\\\&quot;; break;
            case &#39;&quot;&#39;: out += &quot;\\\&quot;&quot;; break;
            case &#39;\n&#39;: out += &quot;\\n&quot;; break;
            case &#39;\r&#39;: out += &quot;\\r&quot;; break;
            case &#39;\t&#39;: out += &quot;\\t&quot;; break;
            default: out.push_back(c); break;
        }
    }
    return out;
}
} // namespace

PipelineArtifacts run_normalize_and_rewrite_pipeline(
    const std::vector&lt;SourceFileUnit&gt;&amp; source_files,
    const std::string&amp; source_pattern,
    const std::string&amp; target_pattern,
    size_t input_file_count,
    const std::vector&lt;std::string&gt;&amp; input_files)
{
    PipelineArtifacts artifacts;
    artifacts.report.source_pattern = source_pattern;
    artifacts.report.target_pattern = target_pattern;
    artifacts.report.input_file_count = input_file_count;
    artifacts.report.total_elapsed_ms = 0.0;
    artifacts.report.peak_estimated_bytes = 0;
    artifacts.report.graph_consistent = false;

    const Clock::time_point pipeline_begin = Clock::now();

    auto run_stage = [&amp;](const std::string&amp; name, auto&amp;&amp; fn) {
        const Clock::time_point begin = Clock::now();
        const size_t bytes = fn();
        const Clock::time_point end = Clock::now();

        StageMetric m;
        m.name = name;
        m.elapsed_ms = std::chrono::duration&lt;double, std::milli&gt;(end - begin).count();
        m.estimated_bytes = bytes;
        artifacts.report.stages.push_back(std::move(m));
        artifacts.report.peak_estimated_bytes = std::max(artifacts.report.peak_estimated_bytes, bytes);
    };

    // 1) Input parse -&gt; base graph
    run_stage(&quot;ParseBaseGraph&quot;, [&amp;]() {
        ParseTreeBuildContext context;
        context.source_pattern = source_pattern;
        context.target_pattern = target_pattern;
        context.input_files = input_files;
        set_parse_tree_build_context(context);
        const ParseTreeBundle trees = build_cpp_parse_trees(source_files);
        artifacts.base_tree = trees.main_tree;
        artifacts.virtual_tree = trees.shadow_tree;
        return estimate_parse_tree_bytes(artifacts.base_tree) +
               estimate_parse_tree_bytes(artifacts.virtual_tree) +
               estimate_symbol_table_bytes();
    });

    // 2) Detect patterns
    run_stage(&quot;DetectPatternInstances&quot;, [&amp;]() {
        artifacts.creational_tree = build_creational_broken_tree(artifacts.base_tree);
        artifacts.behavioural_tree = build_behavioural_broken_tree(artifacts.base_tree);
        return estimate_creational_tree_bytes(artifacts.creational_tree) +
               estimate_parse_tree_bytes(artifacts.behavioural_tree);
    });

    // 3) Create virtual subgraph
    run_stage(&quot;CreateVirtualSubgraph&quot;, [&amp;]() {
        // Shadow AST is built during lexical parsing to preserve scope-local usage context.
        return estimate_parse_tree_bytes(artifacts.virtual_tree);
    });

    // 4) Hash affected nodes (symbol tables)
    run_stage(&quot;HashAffectedNodes&quot;, [&amp;]() {
        rebuild_parse_tree_symbol_tables(artifacts.base_tree);
        return estimate_symbol_table_bytes();
    });

    // 5) Generate monolithic representation
    run_stage(&quot;GenerateMonolithicRepresentation&quot;, [&amp;]() {
        artifacts.monolithic_representation = parse_tree_to_text(artifacts.virtual_tree);
        return artifacts.monolithic_representation.size();
    });

    // 6) Apply target policies (scaffold/no-op)
    run_stage(&quot;ApplyTargetPolicies&quot;, [&amp;]() {
        return estimate_parse_tree_bytes(artifacts.base_tree);
    });

    // 7) Validate consistency
    run_stage(&quot;ValidateGraphConsistency&quot;, [&amp;]() {
        artifacts.report.graph_consistent =
            !artifacts.base_tree.kind.empty() &amp;&amp;
            !artifacts.virtual_tree.kind.empty() &amp;&amp;
            (!artifacts.monolithic_representation.empty());
        return estimate_parse_tree_bytes(artifacts.base_tree);
    });

    const Clock::time_point pipeline_end = Clock::now();
    artifacts.report.total_elapsed_ms =
        std::chrono::duration&lt;double, std::milli&gt;(pipeline_end - pipeline_begin).count();

    return artifacts;
}

std::string pipeline_report_to_json(const PipelineReport&amp; report)
{
    std::ostringstream out;
    out &lt;&lt; &quot;{\n&quot;;
    out &lt;&lt; &quot;  \&quot;source_pattern\&quot;: \&quot;&quot; &lt;&lt; json_escape(report.source_pattern) &lt;&lt; &quot;\&quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;target_pattern\&quot;: \&quot;&quot; &lt;&lt; json_escape(report.target_pattern) &lt;&lt; &quot;\&quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;input_file_count\&quot;: &quot; &lt;&lt; report.input_file_count &lt;&lt; &quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;total_elapsed_ms\&quot;: &quot; &lt;&lt; report.total_elapsed_ms &lt;&lt; &quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;peak_estimated_bytes\&quot;: &quot; &lt;&lt; report.peak_estimated_bytes &lt;&lt; &quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;graph_consistent\&quot;: &quot; &lt;&lt; (report.graph_consistent ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &quot;,\n&quot;;
    out &lt;&lt; &quot;  \&quot;class_registry\&quot;: [\n&quot;;

    const std::vector&lt;ParseSymbol&gt;&amp; class_symbols = getClassSymbolTable();
    for (size_t i = 0; i &lt; class_symbols.size(); ++i)
    {
        const ParseSymbol&amp; s = class_symbols[i];
        out &lt;&lt; &quot;    {\n&quot;;
        out &lt;&lt; &quot;      \&quot;name\&quot;: \&quot;&quot; &lt;&lt; json_escape(s.name) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;name_hash\&quot;: &quot; &lt;&lt; s.name_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;contextual_hash\&quot;: &quot; &lt;&lt; s.contextual_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;hash\&quot;: &quot; &lt;&lt; s.hash_value &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;definition_node_index\&quot;: &quot; &lt;&lt; s.definition_node_index &lt;&lt; &quot;\n&quot;;
        out &lt;&lt; &quot;    }&quot;;
        if (i + 1 &lt; class_symbols.size())
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; &quot;\n&quot;;
    }

    out &lt;&lt; &quot;  ],\n&quot;;
    out &lt;&lt; &quot;  \&quot;class_usages\&quot;: [\n&quot;;

    const std::vector&lt;ParseSymbolUsage&gt;&amp; class_usages = getClassUsageTable();
    for (size_t i = 0; i &lt; class_usages.size(); ++i)
    {
        const ParseSymbolUsage&amp; u = class_usages[i];
        out &lt;&lt; &quot;    {\n&quot;;
        out &lt;&lt; &quot;      \&quot;name\&quot;: \&quot;&quot; &lt;&lt; json_escape(u.name) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;type_string\&quot;: \&quot;&quot; &lt;&lt; json_escape(u.type_string) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;node_kind\&quot;: \&quot;&quot; &lt;&lt; json_escape(u.node_kind) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;node_value\&quot;: \&quot;&quot; &lt;&lt; json_escape(u.node_value) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;node_index\&quot;: &quot; &lt;&lt; u.node_index &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;node_contextual_hash\&quot;: &quot; &lt;&lt; u.node_contextual_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;class_name_hash\&quot;: &quot; &lt;&lt; u.class_name_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;hash_collision\&quot;: &quot; &lt;&lt; (u.hash_collision ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;refactor_candidate\&quot;: &quot; &lt;&lt; (u.refactor_candidate ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;hash\&quot;: &quot; &lt;&lt; u.hash_value &lt;&lt; &quot;\n&quot;;
        out &lt;&lt; &quot;    }&quot;;
        if (i + 1 &lt; class_usages.size())
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; &quot;\n&quot;;
    }

    out &lt;&lt; &quot;  ],\n&quot;;
    out &lt;&lt; &quot;  \&quot;line_hash_traces\&quot;: [\n&quot;;

    const std::vector&lt;LineHashTrace&gt;&amp; traces = get_line_hash_traces();
    for (size_t i = 0; i &lt; traces.size(); ++i)
    {
        const LineHashTrace&amp; t = traces[i];
        out &lt;&lt; &quot;    {\n&quot;;
        out &lt;&lt; &quot;      \&quot;line_number\&quot;: &quot; &lt;&lt; t.line_number &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;class_name\&quot;: \&quot;&quot; &lt;&lt; json_escape(t.class_name) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;class_name_hash\&quot;: &quot; &lt;&lt; t.class_name_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;hit_token_index\&quot;: &quot; &lt;&lt; t.hit_token_index &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;outgoing_hash\&quot;: &quot; &lt;&lt; t.outgoing_hash &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;dirty_token_count\&quot;: &quot; &lt;&lt; t.dirty_token_count &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;hash_collision\&quot;: &quot; &lt;&lt; (t.hash_collision ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; &quot;\n&quot;;
        out &lt;&lt; &quot;    }&quot;;
        if (i + 1 &lt; traces.size())
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; &quot;\n&quot;;
    }

    out &lt;&lt; &quot;  ],\n&quot;;
    out &lt;&lt; &quot;  \&quot;stages\&quot;: [\n&quot;;

    for (size_t i = 0; i &lt; report.stages.size(); ++i)
    {
        const StageMetric&amp; s = report.stages[i];
        out &lt;&lt; &quot;    {\n&quot;;
        out &lt;&lt; &quot;      \&quot;name\&quot;: \&quot;&quot; &lt;&lt; json_escape(s.name) &lt;&lt; &quot;\&quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;elapsed_ms\&quot;: &quot; &lt;&lt; s.elapsed_ms &lt;&lt; &quot;,\n&quot;;
        out &lt;&lt; &quot;      \&quot;estimated_bytes\&quot;: &quot; &lt;&lt; s.estimated_bytes &lt;&lt; &quot;\n&quot;;
        out &lt;&lt; &quot;    }&quot;;
        if (i + 1 &lt; report.stages.size())
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; &quot;\n&quot;;
    }

    out &lt;&lt; &quot;  ]\n&quot;;
    out &lt;&lt; &quot;}\n&quot;;
    return out.str();
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\cli_arguments.cpp ===
#include &quot;cli_arguments.hpp&quot;

#include &lt;string&gt;

bool parse_cli_arguments(int argc, char* argv[], CliArguments&amp; out, std::string&amp; error)
{
    // Required:
    // argv[1] = source design pattern
    // argv[2] = target design pattern
    // argv[3..] = one or many input files
    if (argc &lt; 4)
    {
        error = &quot;Usage: NeoTerritory &lt;source_pattern&gt; &lt;target_pattern&gt; &lt;file1&gt; [file2 ...]&quot;;
        return false;
    }

    out.source_pattern = argv[1] == nullptr ? &quot;&quot; : std::string(argv[1]);
    out.target_pattern = argv[2] == nullptr ? &quot;&quot; : std::string(argv[2]);
    out.input_files.clear();

    for (int i = 3; i &lt; argc; ++i)
    {
        if (argv[i] == nullptr)
        {
            continue;
        }
        const std::string path = argv[i];
        if (!path.empty())
        {
            out.input_files.push_back(path);
        }
    }

    if (out.source_pattern.empty() || out.target_pattern.empty())
    {
        error = &quot;Source and target design pattern parameters are required.&quot;;
        return false;
    }
    if (out.input_files.empty())
    {
        error = &quot;At least one input file is required.&quot;;
        return false;
    }

    return true;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\codebase_output_writer.cpp ===
#include &quot;codebase_output_writer.hpp&quot;

#include &lt;fstream&gt;
#include &lt;cctype&gt;
#include &lt;string&gt;

namespace
{
std::string escape_html(const std::string&amp; input)
{
    std::string out;
    out.reserve(input.size());

    for (char c : input)
    {
        switch (c)
        {
            case &#39;&amp;&#39;: out += &quot;&amp;amp;&quot;; break;
            case &#39;&lt;&#39;: out += &quot;&amp;lt;&quot;; break;
            case &#39;&gt;&#39;: out += &quot;&amp;gt;&quot;; break;
            case &#39;&quot;&#39;: out += &quot;&amp;quot;&quot;; break;
            case &#39;\&#39;&#39;: out += &quot;&amp;#39;&quot;; break;
            default: out.push_back(c); break;
        }
    }

    return out;
}

std::string code_to_html(const std::string&amp; title, const std::string&amp; code)
{
    std::string html;
    html += &quot;&lt;!doctype html&gt;\n&lt;html lang=\&quot;en\&quot;&gt;\n&lt;head&gt;\n&quot;;
    html += &quot;  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n&quot;;
    html += &quot;  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1\&quot;&gt;\n&quot;;
    html += &quot;  &lt;title&gt;&quot; + escape_html(title) + &quot;&lt;/title&gt;\n&quot;;
    html += &quot;  &lt;style&gt;body{font-family:Consolas,monospace;margin:24px;background:#f8fbff;color:#1f2937;}pre{white-space:pre-wrap;border:1px solid #d1d5db;padding:12px;background:#fff;}&lt;/style&gt;\n&quot;;
    html += &quot;&lt;/head&gt;\n&lt;body&gt;\n&quot;;
    html += &quot;  &lt;h1&gt;&quot; + escape_html(title) + &quot;&lt;/h1&gt;\n&quot;;
    html += &quot;  &lt;pre&gt;&quot; + escape_html(code) + &quot;&lt;/pre&gt;\n&quot;;
    html += &quot;&lt;/body&gt;\n&lt;/html&gt;\n&quot;;
    return html;
}

std::string sanitize_component(const std::string&amp; text)
{
    std::string out;
    out.reserve(text.size());

    for (char c : text)
    {
        const unsigned char uc = static_cast&lt;unsigned char&gt;(c);
        if (std::isalnum(uc) || c == &#39;_&#39; || c == &#39;-&#39;)
        {
            out.push_back(c);
        }
        else if (c == &#39; &#39; || c == &#39;/&#39;)
        {
            out.push_back(&#39;_&#39;);
        }
    }

    if (out.empty())
    {
        out = &quot;unknown_target&quot;;
    }

    return out;
}
} // namespace

bool write_codebase_outputs(
    const std::string&amp; base_code,
    const std::string&amp; target_code,
    const std::string&amp; target_pattern,
    CodebaseOutputPaths&amp; out_paths)
{
    const std::string safe_target_pattern = sanitize_component(target_pattern);

    out_paths.base_cpp_path = &quot;generated_base_code.cpp&quot;;
    out_paths.target_cpp_path = &quot;generated_target_code_&quot; + safe_target_pattern + &quot;.cpp&quot;;
    out_paths.base_html_path = &quot;generated_base_code.html&quot;;
    out_paths.target_html_path = &quot;generated_target_code_&quot; + safe_target_pattern + &quot;.html&quot;;

    std::ofstream base_cpp(out_paths.base_cpp_path);
    std::ofstream target_cpp(out_paths.target_cpp_path);
    std::ofstream base_html(out_paths.base_html_path);
    std::ofstream target_html(out_paths.target_html_path);

    if (!base_cpp || !target_cpp || !base_html || !target_html)
    {
        return false;
    }

    base_cpp &lt;&lt; base_code;
    target_cpp &lt;&lt; target_code;
    base_html &lt;&lt; code_to_html(&quot;Generated Base Code&quot;, base_code);
    target_html &lt;&lt; code_to_html(&quot;Generated Target Code&quot;, target_code);
    return true;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\language_tokens.cpp ===
#include &quot;language_tokens.hpp&quot;

#include &lt;algorithm&gt;
#include &lt;cctype&gt;
#include &lt;stdexcept&gt;

namespace
{
LanguageTokenConfig build_cpp_tokens()
{
    LanguageTokenConfig cfg;

    cfg.node_translation_unit = &quot;TranslationUnit&quot;;
    cfg.node_block = &quot;Block&quot;;
    cfg.node_statement = &quot;Statement&quot;;
    cfg.node_return_statement = &quot;ReturnStatement&quot;;
    cfg.node_class_decl = &quot;ClassDecl&quot;;
    cfg.node_struct_decl = &quot;StructDecl&quot;;
    cfg.node_namespace_decl = &quot;NamespaceDecl&quot;;
    cfg.node_conditional_statement = &quot;ConditionalStatement&quot;;
    cfg.node_loop_statement = &quot;LoopStatement&quot;;
    cfg.node_assignment_or_decl = &quot;AssignmentOrVarDecl&quot;;
    cfg.node_member_assignment = &quot;MemberAssignment&quot;;

    cfg.token_open_brace = &quot;{&quot;;
    cfg.token_close_brace = &quot;}&quot;;
    cfg.token_statement_end = &quot;;&quot;;
    cfg.token_assignment = &quot;=&quot;;
    cfg.token_scope_operator = &quot;::&quot;;
    cfg.token_member_arrow = &quot;-&gt;&quot;;

    cfg.class_keywords = {&quot;class&quot;, &quot;struct&quot;};
    cfg.conditional_keywords = {&quot;if&quot;, &quot;switch&quot;, &quot;else&quot;};
    cfg.loop_keywords = {&quot;for&quot;, &quot;while&quot;, &quot;do&quot;};
    cfg.function_exclusion_keywords = {
        &quot;if&quot;, &quot;else&quot;, &quot;switch&quot;, &quot;for&quot;, &quot;while&quot;, &quot;do&quot;, &quot;class&quot;, &quot;struct&quot;
    };
    cfg.primitive_type_keywords = {
        &quot;auto&quot;, &quot;bool&quot;, &quot;char&quot;, &quot;double&quot;, &quot;float&quot;, &quot;int&quot;, &quot;long&quot;, &quot;short&quot;,
        &quot;signed&quot;, &quot;size_t&quot;, &quot;std&quot;, &quot;string&quot;, &quot;unsigned&quot;, &quot;void&quot;
    };
    cfg.allocator_keywords = {&quot;new&quot;};
    cfg.allocator_template_functions = {&quot;make_unique&quot;, &quot;make_shared&quot;, &quot;allocate_shared&quot;};

    return cfg;
}
} // namespace

const LanguageTokenConfig&amp; language_tokens(LanguageId language_id)
{
    static const LanguageTokenConfig cpp_tokens = build_cpp_tokens();

    switch (language_id)
    {
        case LanguageId::Cpp:
            return cpp_tokens;
    }

    throw std::runtime_error(&quot;Unsupported language id&quot;);
}

std::string lowercase_ascii(const std::string&amp; input)
{
    std::string lowered = input;
    std::transform(lowered.begin(), lowered.end(), lowered.begin(), [](unsigned char c) {
        return static_cast&lt;char&gt;(std::tolower(c));
    });
    return lowered;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\lexical_structure_hooks.cpp ===
#include &quot;lexical_structure_hooks.hpp&quot;

#include &quot;language_tokens.hpp&quot;

#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace
{
class IStructuralAnalyzer
{
public:
    virtual ~IStructuralAnalyzer() = default;
    virtual const char* strategy_name() const = 0;
    virtual bool is_crucial_class(
        const std::string&amp; class_name,
        const std::vector&lt;std::string&gt;&amp; declaration_tokens) const = 0;
};

class KeywordAnalyzer final : public IStructuralAnalyzer
{
public:
    KeywordAnalyzer(std::string name, std::vector&lt;std::string&gt; keywords)
        : strategy_name_(std::move(name)), keywords_(std::move(keywords))
    {
    }

    const char* strategy_name() const override
    {
        return strategy_name_.c_str();
    }

    bool is_crucial_class(
        const std::string&amp; class_name,
        const std::vector&lt;std::string&gt;&amp; declaration_tokens) const override
    {
        const std::string lowered_name = lowercase_ascii(class_name);
        for (const std::string&amp; keyword : keywords_)
        {
            if (lowered_name.find(keyword) != std::string::npos)
            {
                return true;
            }
        }

        for (const std::string&amp; token : declaration_tokens)
        {
            const std::string lowered_token = lowercase_ascii(token);
            for (const std::string&amp; keyword : keywords_)
            {
                if (lowered_token.find(keyword) != std::string::npos)
                {
                    return true;
                }
            }
        }

        return false;
    }

private:
    std::string strategy_name_;
    std::vector&lt;std::string&gt; keywords_;
};

const IStructuralAnalyzer&amp; select_analyzer(const std::string&amp; source_pattern)
{
    static const KeywordAnalyzer factory_analyzer(
        &quot;FactoryStructuralStrategy&quot;,
        {&quot;factory&quot;, &quot;creator&quot;, &quot;create&quot;});
    static const KeywordAnalyzer singleton_analyzer(
        &quot;SingletonStructuralStrategy&quot;,
        {&quot;singleton&quot;, &quot;instance&quot;, &quot;config&quot;});
    static const KeywordAnalyzer builder_analyzer(
        &quot;BuilderStructuralStrategy&quot;,
        {&quot;builder&quot;, &quot;build&quot;, &quot;director&quot;});
    static const KeywordAnalyzer strategy_analyzer(
        &quot;StrategyStructuralStrategy&quot;,
        {&quot;strategy&quot;, &quot;context&quot;});
    static const KeywordAnalyzer observer_analyzer(
        &quot;ObserverStructuralStrategy&quot;,
        {&quot;observer&quot;, &quot;subject&quot;, &quot;listener&quot;});
    static const KeywordAnalyzer null_analyzer(
        &quot;NullStructuralStrategy&quot;,
        {});

    const std::string pattern = lowercase_ascii(source_pattern);
    if (pattern == &quot;factory&quot;)
    {
        return factory_analyzer;
    }
    if (pattern == &quot;singleton&quot;)
    {
        return singleton_analyzer;
    }
    if (pattern == &quot;builder&quot;)
    {
        return builder_analyzer;
    }
    if (pattern == &quot;strategy&quot;)
    {
        return strategy_analyzer;
    }
    if (pattern == &quot;observer&quot;)
    {
        return observer_analyzer;
    }

    return null_analyzer;
}

std::unordered_map&lt;std::string, size_t&gt; g_crucial_class_hash_by_name;
std::vector&lt;CrucialClassInfo&gt; g_crucial_class_registry;
} // namespace

void on_class_scanned_structural_hook(
    const std::string&amp; class_name,
    const std::vector&lt;std::string&gt;&amp; declaration_tokens,
    const ParseTreeBuildContext&amp; context)
{
    const IStructuralAnalyzer&amp; analyzer = select_analyzer(context.source_pattern);
    if (!analyzer.is_crucial_class(class_name, declaration_tokens))
    {
        return;
    }

    if (g_crucial_class_hash_by_name.find(class_name) != g_crucial_class_hash_by_name.end())
    {
        return;
    }

    const size_t class_name_hash = std::hash&lt;std::string&gt;{}(class_name);
    g_crucial_class_hash_by_name[class_name] = class_name_hash;

    CrucialClassInfo info;
    info.name = class_name;
    info.class_name_hash = class_name_hash;
    info.strategy_name = analyzer.strategy_name();
    g_crucial_class_registry.push_back(std::move(info));
}

void reset_structural_analysis_state()
{
    g_crucial_class_hash_by_name.clear();
    g_crucial_class_registry.clear();
}

bool is_crucial_class_name(const std::string&amp; class_name, size_t* out_class_name_hash)
{
    const auto it = g_crucial_class_hash_by_name.find(class_name);
    if (it == g_crucial_class_hash_by_name.end())
    {
        return false;
    }

    if (out_class_name_hash != nullptr)
    {
        *out_class_name_hash = it-&gt;second;
    }
    return true;
}

const std::vector&lt;CrucialClassInfo&gt;&amp; get_crucial_class_registry()
{
    return g_crucial_class_registry;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\parse_tree.cpp ===
#include &quot;parse_tree.hpp&quot;

#include &quot;language_tokens.hpp&quot;
#include &quot;lexical_structure_hooks.hpp&quot;
#include &quot;parse_tree_symbols.hpp&quot;
#include &quot;tree_html_renderer.hpp&quot;

#include &lt;cctype&gt;
#include &lt;functional&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;unordered_set&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace
{
ParseTreeBuildContext g_build_context;
std::vector&lt;LineHashTrace&gt; g_line_hash_traces;

size_t hash_combine_token(size_t seed, const std::string&amp; token)
{
    return std::hash&lt;std::string&gt;{}(std::to_string(seed) + &quot;|&quot; + token);
}

size_t derive_child_context_hash(
    size_t parent_hash,
    const std::string&amp; kind,
    const std::string&amp; value,
    size_t sibling_index)
{
    return std::hash&lt;std::string&gt;{}(
        std::to_string(parent_hash) +
        &quot;|&quot; + kind +
        &quot;|&quot; + value +
        &quot;|&quot; + std::to_string(sibling_index));
}

void add_unique_hash(std::vector&lt;size_t&gt;&amp; hashes, size_t hash_value)
{
    for (size_t existing : hashes)
    {
        if (existing == hash_value)
        {
            return;
        }
    }
    hashes.push_back(hash_value);
}

std::string usage_hash_suffix(const std::vector&lt;size_t&gt;&amp; active_usage_hashes)
{
    if (active_usage_hashes.empty())
    {
        return {};
    }

    std::ostringstream out;
    out &lt;&lt; &quot;@[&quot;;
    for (size_t i = 0; i &lt; active_usage_hashes.size(); ++i)
    {
        if (i &gt; 0)
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; active_usage_hashes[i];
    }
    out &lt;&lt; &quot;]&quot;;
    return out.str();
}

std::string usage_hash_list(const std::vector&lt;size_t&gt;&amp; usage_hashes)
{
    if (usage_hashes.empty())
    {
        return {};
    }

    std::ostringstream out;
    for (size_t i = 0; i &lt; usage_hashes.size(); ++i)
    {
        if (i &gt; 0)
        {
            out &lt;&lt; &quot;,&quot;;
        }
        out &lt;&lt; usage_hashes[i];
    }
    return out.str();
}

std::vector&lt;std::string&gt; tokenize_text(const std::string&amp; source)
{
    std::vector&lt;std::string&gt; tokens;
    std::string current;

    auto flush_current = [&amp;]() {
        if (!current.empty())
        {
            tokens.push_back(current);
            current.clear();
        }
    };

    for (size_t i = 0; i &lt; source.size(); ++i)
    {
        const char c = source[i];

        if (std::isspace(static_cast&lt;unsigned char&gt;(c)))
        {
            flush_current();
            continue;
        }

        if (std::isalnum(static_cast&lt;unsigned char&gt;(c)) || c == &#39;_&#39;)
        {
            current.push_back(c);
            continue;
        }

        flush_current();

        if ((c == &#39;:&#39; || c == &#39;=&#39; || c == &#39;!&#39; || c == &#39;&lt;&#39; || c == &#39;&gt;&#39;) &amp;&amp;
            i + 1 &lt; source.size() &amp;&amp; source[i + 1] == &#39;=&#39;)
        {
            tokens.emplace_back(source.substr(i, 2));
            ++i;
            continue;
        }

        if (c == &#39;:&#39; &amp;&amp; i + 1 &lt; source.size() &amp;&amp; source[i + 1] == &#39;:&#39;)
        {
            tokens.emplace_back(&quot;::&quot;);
            ++i;
            continue;
        }
        if (c == &#39;-&#39; &amp;&amp; i + 1 &lt; source.size() &amp;&amp; source[i + 1] == &#39;&gt;&#39;)
        {
            tokens.emplace_back(&quot;-&gt;&quot;);
            ++i;
            continue;
        }

        tokens.emplace_back(1, c);
    }

    flush_current();
    return tokens;
}

std::string join_tokens(const std::vector&lt;std::string&gt;&amp; tokens, size_t start, size_t end)
{
    if (start &gt;= end)
    {
        return {};
    }

    std::ostringstream out;
    for (size_t i = start; i &lt; end; ++i)
    {
        if (i &gt; start)
        {
            out &lt;&lt; &#39; &#39;;
        }
        out &lt;&lt; tokens[i];
    }
    return out.str();
}

std::vector&lt;std::string&gt; split_lines(const std::string&amp; source)
{
    std::vector&lt;std::string&gt; lines;
    std::string current;

    for (char c : source)
    {
        if (c == &#39;\n&#39;)
        {
            lines.push_back(current);
            current.clear();
        }
        else if (c != &#39;\r&#39;)
        {
            current.push_back(c);
        }
    }
    lines.push_back(current);

    return lines;
}

bool is_type_keyword(const std::string&amp; token)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    return cfg.primitive_type_keywords.find(token) != cfg.primitive_type_keywords.end();
}

std::string detect_statement_kind(const std::vector&lt;std::string&gt;&amp; statement_tokens)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    if (statement_tokens.empty())
    {
        return cfg.node_statement;
    }

    const std::string&amp; first_token = statement_tokens.front();
    if (cfg.conditional_keywords.find(first_token) != cfg.conditional_keywords.end())
    {
        return cfg.node_conditional_statement;
    }
    if (cfg.loop_keywords.find(first_token) != cfg.loop_keywords.end())
    {
        return cfg.node_loop_statement;
    }
    if (first_token == &quot;return&quot;) return cfg.node_return_statement;
    if (first_token == &quot;class&quot;) return cfg.node_class_decl;
    if (first_token == &quot;struct&quot;) return cfg.node_struct_decl;
    if (first_token == &quot;namespace&quot;) return cfg.node_namespace_decl;
    bool has_assignment = false;
    bool has_member_arrow = false;
    for (const std::string&amp; token : statement_tokens)
    {
        if (token == cfg.token_assignment)
        {
            has_assignment = true;
        }
        if (token == cfg.token_member_arrow)
        {
            has_member_arrow = true;
        }
    }

    if (has_assignment &amp;&amp; has_member_arrow)
    {
        return cfg.node_member_assignment;
    }

    if (has_assignment || is_type_keyword(first_token))
    {
        return cfg.node_assignment_or_decl;
    }

    return cfg.node_statement;
}

ParseTreeNode* node_at_path(ParseTreeNode&amp; root, const std::vector&lt;size_t&gt;&amp; path)
{
    ParseTreeNode* target = &amp;root;
    for (size_t idx : path)
    {
        if (idx &gt;= target-&gt;children.size())
        {
            return nullptr;
        }
        target = &amp;target-&gt;children[idx];
    }
    return target;
}

size_t append_node_at_path(ParseTreeNode&amp; root, const std::vector&lt;size_t&gt;&amp; path, ParseTreeNode node)
{
    ParseTreeNode* target = node_at_path(root, path);
    if (target == nullptr)
    {
        return 0;
    }

    const size_t sibling_index = target-&gt;children.size();
    node.contextual_hash = derive_child_context_hash(target-&gt;contextual_hash, node.kind, node.value, sibling_index);
    target-&gt;children.push_back(std::move(node));
    return sibling_index;
}

void register_classes_in_line(
    const std::vector&lt;std::string&gt;&amp; line_tokens,
    std::unordered_map&lt;size_t, std::vector&lt;std::string&gt;&gt;&amp; class_hash_registry)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    for (size_t i = 0; i + 1 &lt; line_tokens.size(); ++i)
    {
        const std::string kw = lowercase_ascii(line_tokens[i]);
        if (cfg.class_keywords.find(kw) == cfg.class_keywords.end())
        {
            continue;
        }

        const std::string class_name = line_tokens[i + 1];
        const size_t class_hash = std::hash&lt;std::string&gt;{}(class_name);

        class_hash_registry[class_hash].push_back(class_name);
        on_class_scanned_structural_hook(class_name, line_tokens, g_build_context);
    }
}

bool token_hits_registered_class(
    const std::string&amp; token,
    const std::unordered_map&lt;size_t, std::vector&lt;std::string&gt;&gt;&amp; class_hash_registry,
    size_t&amp; out_class_hash,
    bool&amp; out_collision)
{
    out_class_hash = std::hash&lt;std::string&gt;{}(token);
    const auto hit = class_hash_registry.find(out_class_hash);
    if (hit == class_hash_registry.end())
    {
        return false;
    }

    bool exact_name_match = false;
    for (const std::string&amp; name : hit-&gt;second)
    {
        if (name == token)
        {
            exact_name_match = true;
            break;
        }
    }

    out_collision = !exact_name_match || hit-&gt;second.size() &gt; 1;
    return exact_name_match;
}

void collect_line_hash_trace(
    size_t line_number,
    const std::vector&lt;std::string&gt;&amp; line_tokens,
    size_t hit_token_index,
    size_t class_hash,
    bool hash_collision,
    size_t scope_hash)
{
    if (line_tokens.empty() || hit_token_index &gt;= line_tokens.size())
    {
        return;
    }

    size_t current_hash = hash_combine_token(scope_hash, std::to_string(class_hash));
    std::vector&lt;size_t&gt; chain;

    for (size_t i = hit_token_index; i &gt; 0; --i)
    {
        current_hash = hash_combine_token(current_hash, line_tokens[i - 1]);
        chain.push_back(current_hash);
    }
    for (size_t i = hit_token_index + 1; i &lt; line_tokens.size(); ++i)
    {
        current_hash = hash_combine_token(current_hash, line_tokens[i]);
        chain.push_back(current_hash);
    }

    LineHashTrace trace;
    trace.line_number = line_number;
    trace.class_name = line_tokens[hit_token_index];
    trace.class_name_hash = class_hash;
    trace.hit_token_index = hit_token_index;
    trace.outgoing_hash = current_hash;
    trace.hash_collision = hash_collision;
    trace.dirty_token_count = line_tokens.size();
    trace.hash_chain = std::move(chain);
    g_line_hash_traces.push_back(std::move(trace));
}

std::string file_basename(const std::string&amp; path)
{
    const size_t slash = path.find_last_of(&quot;/\\&quot;);
    if (slash == std::string::npos)
    {
        return path;
    }
    return path.substr(slash + 1);
}

std::string include_target_from_line(const std::string&amp; line)
{
    const std::vector&lt;std::string&gt; t = tokenize_text(line);
    if (t.size() &lt; 3 || t[0] != &quot;#&quot; || lowercase_ascii(t[1]) != &quot;include&quot;)
    {
        return {};
    }

    if (t[2] == &quot;&lt;&quot;)
    {
        std::string out;
        for (size_t i = 3; i &lt; t.size() &amp;&amp; t[i] != &quot;&gt;&quot;; ++i)
        {
            out += t[i];
        }
        return out;
    }

    if (t[2] == &quot;\&quot;&quot;)
    {
        std::string out;
        for (size_t i = 3; i &lt; t.size() &amp;&amp; t[i] != &quot;\&quot;&quot;; ++i)
        {
            out += t[i];
        }
        return out;
    }

    return t[2];
}

void clear_statement_buffers(
    std::vector&lt;std::string&gt;&amp; statement_tokens,
    std::vector&lt;std::string&gt;&amp; tracked_statement_tokens,
    std::vector&lt;size_t&gt;&amp; statement_usage_hashes)
{
    statement_tokens.clear();
    tracked_statement_tokens.clear();
    statement_usage_hashes.clear();
}

void parse_file_content_into_node(
    const SourceFileUnit&amp; file,
    ParseTreeNode&amp; file_node,
    std::unordered_map&lt;size_t, std::vector&lt;std::string&gt;&gt;&amp; class_hash_registry)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; lines = split_lines(file.content);

    std::vector&lt;size_t&gt; context_path;
    std::vector&lt;std::vector&lt;size_t&gt;&gt; scope_usage_hashes(1);
    std::vector&lt;std::string&gt; statement_tokens;
    std::vector&lt;std::string&gt; tracked_statement_tokens;
    std::vector&lt;size_t&gt; statement_usage_hashes;

    auto flush_statement = [&amp;]() {
        if (statement_tokens.empty())
        {
            return;
        }

        ParseTreeNode node;
        node.kind = detect_statement_kind(statement_tokens);
        node.value = join_tokens(statement_tokens, 0, statement_tokens.size());
        node.propagated_usage_hashes = statement_usage_hashes;

        const std::string annotated = join_tokens(tracked_statement_tokens, 0, tracked_statement_tokens.size());
        if (annotated != node.value)
        {
            node.annotated_value = annotated;
        }

        append_node_at_path(file_node, context_path, std::move(node));
        clear_statement_buffers(statement_tokens, tracked_statement_tokens, statement_usage_hashes);
    };

    auto mark_statement_with_scope_hashes = [&amp;]() {
        for (size_t usage_hash : scope_usage_hashes.back())
        {
            add_unique_hash(statement_usage_hashes, usage_hash);
        }
    };

    for (size_t line_idx = 0; line_idx &lt; lines.size(); ++line_idx)
    {
        const std::vector&lt;std::string&gt; line_tokens = tokenize_text(lines[line_idx]);

        const std::string include_target = include_target_from_line(lines[line_idx]);
        if (!include_target.empty())
        {
            ParseTreeNode include_node;
            include_node.kind = &quot;IncludeDependency&quot;;
            include_node.value = include_target;
            append_node_at_path(file_node, {}, std::move(include_node));
        }

        register_classes_in_line(line_tokens, class_hash_registry);

        const ParseTreeNode* current_scope_node = node_at_path(file_node, context_path);
        const size_t current_scope_hash =
            current_scope_node != nullptr ? current_scope_node-&gt;contextual_hash : file_node.contextual_hash;

        for (size_t token_idx = 0; token_idx &lt; line_tokens.size(); ++token_idx)
        {
            size_t class_hash = 0;
            bool hash_collision = false;
            if (token_hits_registered_class(line_tokens[token_idx], class_hash_registry, class_hash, hash_collision))
            {
                collect_line_hash_trace(
                    line_idx + 1,
                    line_tokens,
                    token_idx,
                    class_hash,
                    hash_collision,
                    current_scope_hash);
            }
        }

        for (const std::string&amp; token : line_tokens)
        {
            if (token == cfg.token_open_brace)
            {
                ParseTreeNode block;
                block.kind = cfg.node_block;
                block.value = join_tokens(statement_tokens, 0, statement_tokens.size());
                block.propagated_usage_hashes = statement_usage_hashes;

                const std::string annotated = join_tokens(tracked_statement_tokens, 0, tracked_statement_tokens.size());
                if (annotated != block.value)
                {
                    block.annotated_value = annotated;
                }

                const size_t new_index = append_node_at_path(file_node, context_path, std::move(block));
                context_path.push_back(new_index);
                scope_usage_hashes.push_back(scope_usage_hashes.back());
                clear_statement_buffers(statement_tokens, tracked_statement_tokens, statement_usage_hashes);
                continue;
            }

            if (token == cfg.token_close_brace)
            {
                flush_statement();
                if (!context_path.empty())
                {
                    context_path.pop_back();
                }
                if (scope_usage_hashes.size() &gt; 1)
                {
                    scope_usage_hashes.pop_back();
                }
                continue;
            }

            if (token == cfg.token_statement_end)
            {
                flush_statement();
                continue;
            }

            std::string tracked_token = token;
            const std::string suffix = usage_hash_suffix(scope_usage_hashes.back());
            if (!suffix.empty())
            {
                tracked_token += suffix;
            }

            statement_tokens.push_back(token);
            tracked_statement_tokens.push_back(std::move(tracked_token));
            mark_statement_with_scope_hashes();

            size_t crucial_class_hash = 0;
            if (is_crucial_class_name(token, &amp;crucial_class_hash))
            {
                ParseTreeNode* scope_node = node_at_path(file_node, context_path);
                const size_t scope_hash =
                    scope_node != nullptr ? scope_node-&gt;contextual_hash : file_node.contextual_hash;
                const size_t scoped_usage_hash = hash_combine_token(scope_hash, std::to_string(crucial_class_hash));
                add_unique_hash(scope_usage_hashes.back(), scoped_usage_hash);
                add_unique_hash(statement_usage_hashes, scoped_usage_hash);
            }
        }
    }

    flush_statement();
}

void collect_class_definitions_by_file(
    const ParseTreeNode&amp; node,
    const std::string&amp; current_file,
    std::unordered_map&lt;std::string, std::string&gt;&amp; class_def_file)
{
    if (node.kind == &quot;Block&quot;)
    {
        const std::vector&lt;std::string&gt; words = tokenize_text(node.value);
        if (words.size() &gt;= 2)
        {
            const std::string kw = lowercase_ascii(words[0]);
            if (kw == &quot;class&quot; || kw == &quot;struct&quot;)
            {
                class_def_file[words[1]] = current_file;
            }
        }
    }

    for (const ParseTreeNode&amp; child : node.children)
    {
        collect_class_definitions_by_file(child, current_file, class_def_file);
    }
}

void collect_symbol_dependencies_for_file(
    const ParseTreeNode&amp; node,
    const std::string&amp; current_file,
    const std::unordered_map&lt;std::string, std::string&gt;&amp; class_def_file,
    std::unordered_set&lt;std::string&gt;&amp; emitted,
    std::vector&lt;ParseTreeNode&gt;&amp; out_dependencies)
{
    const std::string&amp; searchable_value = node.value;
    if (!searchable_value.empty())
    {
        const std::vector&lt;std::string&gt; words = tokenize_text(searchable_value);
        for (const std::string&amp; word : words)
        {
            const auto it = class_def_file.find(word);
            if (it == class_def_file.end() || it-&gt;second == current_file)
            {
                continue;
            }

            const std::string key = current_file + &quot;|&quot; + it-&gt;second + &quot;|&quot; + word;
            if (emitted.insert(key).second)
            {
                ParseTreeNode dep;
                dep.kind = &quot;SymbolDependency&quot;;
                dep.value = word + &quot; -&gt; &quot; + it-&gt;second;
                out_dependencies.push_back(std::move(dep));
            }
        }
    }

    for (const ParseTreeNode&amp; child : node.children)
    {
        collect_symbol_dependencies_for_file(child, current_file, class_def_file, emitted, out_dependencies);
    }
}

void resolve_include_dependencies(
    ParseTreeNode&amp; node,
    const std::unordered_map&lt;std::string, std::string&gt;&amp; basename_to_path)
{
    if (node.kind == &quot;IncludeDependency&quot;)
    {
        const auto it = basename_to_path.find(node.value);
        if (it != basename_to_path.end())
        {
            node.value = node.value + &quot; -&gt; &quot; + it-&gt;second;
        }
    }

    for (ParseTreeNode&amp; child : node.children)
    {
        resolve_include_dependencies(child, basename_to_path);
    }
}

bool append_shadow_subtree_if_relevant(const ParseTreeNode&amp; source, ParseTreeNode&amp; out_shadow_node)
{
    std::vector&lt;ParseTreeNode&gt; kept_children;
    kept_children.reserve(source.children.size());

    for (const ParseTreeNode&amp; child : source.children)
    {
        ParseTreeNode shadow_child;
        if (append_shadow_subtree_if_relevant(child, shadow_child))
        {
            kept_children.push_back(std::move(shadow_child));
        }
    }

    const bool self_relevant = !source.propagated_usage_hashes.empty();
    if (!self_relevant &amp;&amp; kept_children.empty())
    {
        return false;
    }

    out_shadow_node.kind = source.kind;
    out_shadow_node.value = source.value;
    out_shadow_node.annotated_value = source.annotated_value;
    out_shadow_node.contextual_hash = source.contextual_hash;
    out_shadow_node.propagated_usage_hashes = source.propagated_usage_hashes;
    out_shadow_node.children = std::move(kept_children);
    return true;
}
} // namespace

void set_parse_tree_build_context(const ParseTreeBuildContext&amp; context)
{
    g_build_context = context;
    reset_structural_analysis_state();
}

const ParseTreeBuildContext&amp; get_parse_tree_build_context()
{
    return g_build_context;
}

const std::vector&lt;LineHashTrace&gt;&amp; get_line_hash_traces()
{
    return g_line_hash_traces;
}

ParseTreeNode build_cpp_parse_tree(const std::string&amp; source)
{
    std::vector&lt;SourceFileUnit&gt; single_file;
    single_file.push_back(SourceFileUnit{&quot;&lt;memory&gt;&quot;, source});
    return build_cpp_parse_tree(single_file);
}

ParseTreeNode build_cpp_parse_tree(const std::vector&lt;SourceFileUnit&gt;&amp; files)
{
    ParseTreeBundle bundle = build_cpp_parse_trees(files);
    return bundle.main_tree;
}

ParseTreeBundle build_cpp_parse_trees(const std::vector&lt;SourceFileUnit&gt;&amp; files)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);

    ParseTreeBundle bundle;
    bundle.main_tree.kind = cfg.node_translation_unit;
    bundle.main_tree.value = &quot;Root&quot;;
    bundle.main_tree.contextual_hash = std::hash&lt;std::string&gt;{}(cfg.node_translation_unit + &quot;|Root|main&quot;);

    bundle.shadow_tree.kind = cfg.node_translation_unit;
    bundle.shadow_tree.value = &quot;Root&quot;;
    bundle.shadow_tree.contextual_hash = bundle.main_tree.contextual_hash;

    g_line_hash_traces.clear();
    reset_structural_analysis_state();

    std::unordered_map&lt;size_t, std::vector&lt;std::string&gt;&gt; class_hash_registry;
    std::unordered_map&lt;std::string, std::string&gt; class_def_file;
    std::unordered_map&lt;std::string, std::string&gt; basename_to_path;

    bundle.main_tree.children.reserve(files.size());
    bundle.shadow_tree.children.reserve(files.size());
    for (size_t i = 0; i &lt; files.size(); ++i)
    {
        const SourceFileUnit&amp; file = files[i];

        ParseTreeNode main_file_node;
        main_file_node.kind = &quot;FileUnit&quot;;
        main_file_node.value = file.path;
        main_file_node.contextual_hash = derive_child_context_hash(
            bundle.main_tree.contextual_hash,
            main_file_node.kind,
            main_file_node.value,
            bundle.main_tree.children.size());
        bundle.main_tree.children.push_back(std::move(main_file_node));

        ParseTreeNode shadow_file_node;
        shadow_file_node.kind = &quot;FileUnit&quot;;
        shadow_file_node.value = file.path;
        shadow_file_node.contextual_hash = main_file_node.contextual_hash;
        bundle.shadow_tree.children.push_back(std::move(shadow_file_node));

        basename_to_path[file_basename(file.path)] = file.path;
    }

    for (size_t i = 0; i &lt; files.size(); ++i)
    {
        parse_file_content_into_node(files[i], bundle.main_tree.children[i], class_hash_registry);
        collect_class_definitions_by_file(bundle.main_tree.children[i], files[i].path, class_def_file);
    }

    for (ParseTreeNode&amp; file_node : bundle.main_tree.children)
    {
        resolve_include_dependencies(file_node, basename_to_path);

        std::unordered_set&lt;std::string&gt; emitted;
        std::vector&lt;ParseTreeNode&gt; symbol_deps;
        collect_symbol_dependencies_for_file(
            file_node,
            file_node.value,
            class_def_file,
            emitted,
            symbol_deps);

        for (ParseTreeNode&amp; dep : symbol_deps)
        {
            append_node_at_path(file_node, {}, std::move(dep));
        }
    }

    for (size_t i = 0; i &lt; bundle.main_tree.children.size() &amp;&amp; i &lt; bundle.shadow_tree.children.size(); ++i)
    {
        ParseTreeNode&amp; shadow_file = bundle.shadow_tree.children[i];
        shadow_file.children.clear();

        for (const ParseTreeNode&amp; child : bundle.main_tree.children[i].children)
        {
            ParseTreeNode filtered;
            if (append_shadow_subtree_if_relevant(child, filtered))
            {
                shadow_file.children.push_back(std::move(filtered));
            }
        }
    }

    rebuild_parse_tree_symbol_tables(bundle.main_tree);
    return bundle;
}

std::string parse_tree_to_text(const ParseTreeNode&amp; root)
{
    std::ostringstream out;

    std::function&lt;void(const ParseTreeNode&amp;, int)&gt; walk = [&amp;](const ParseTreeNode&amp; node, int depth) {
        out &lt;&lt; std::string(static_cast&lt;size_t&gt;(depth) * 2, &#39; &#39;) &lt;&lt; node.kind;

        const std::string&amp; display_value = node.annotated_value.empty() ? node.value : node.annotated_value;
        if (!display_value.empty())
        {
            out &lt;&lt; &quot;: &quot; &lt;&lt; display_value;
        }

        out &lt;&lt; &quot; | ctx_hash=&quot; &lt;&lt; node.contextual_hash;
        if (!node.propagated_usage_hashes.empty())
        {
            out &lt;&lt; &quot; | scope_usage_hashes=&quot; &lt;&lt; usage_hash_list(node.propagated_usage_hashes);
        }
        out &lt;&lt; &#39;\n&#39;;

        for (const ParseTreeNode&amp; child : node.children)
        {
            walk(child, depth + 1);
        }
    };

    walk(root, 0);
    return out.str();
}

std::string parse_tree_to_html(const ParseTreeNode&amp; root)
{
    return render_tree_html(root, &quot;C++ Parse Tree&quot;);
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\parse_tree_code_generator.cpp ===
#include &quot;parse_tree_code_generator.hpp&quot;
#include &quot;Factory/factory_pattern_logic.hpp&quot;
#include &quot;language_tokens.hpp&quot;
#include &quot;parse_tree.hpp&quot;

#include &lt;regex&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;unordered_set&gt;
#include &lt;vector&gt;

namespace
{
std::string lower(const std::string&amp; s)
{
    return lowercase_ascii(s);
}

size_t find_matching_brace(const std::string&amp; text, size_t open_pos)
{
    if (open_pos &gt;= text.size() || text[open_pos] != &#39;{&#39;)
    {
        return std::string::npos;
    }

    int depth = 0;
    for (size_t i = open_pos; i &lt; text.size(); ++i)
    {
        if (text[i] == &#39;{&#39;)
        {
            ++depth;
        }
        else if (text[i] == &#39;}&#39;)
        {
            --depth;
            if (depth == 0)
            {
                return i;
            }
        }
    }

    return std::string::npos;
}

std::vector&lt;std::string&gt; extract_factory_class_names(const std::string&amp; source)
{
    std::vector&lt;std::string&gt; names;
    std::unordered_set&lt;std::string&gt; seen;

    const ParseTreeNode parse_root = build_cpp_parse_tree(source);
    const CreationalTreeNode factory_tree = build_factory_pattern_tree(parse_root);

    for (const CreationalTreeNode&amp; class_node : factory_tree.children)
    {
        if (class_node.kind != &quot;ClassNode&quot;)
        {
            continue;
        }
        const std::string&amp; name = class_node.label;
        if (seen.insert(name).second)
        {
            names.push_back(name);
        }
    }

    return names;
}

void inject_singleton_accessor(std::string&amp; source, const std::string&amp; class_name)
{
    const std::string class_kw = &quot;class &quot; + class_name;
    const std::string struct_kw = &quot;struct &quot; + class_name;

    size_t class_pos = source.find(class_kw);
    if (class_pos == std::string::npos)
    {
        class_pos = source.find(struct_kw);
    }
    if (class_pos == std::string::npos)
    {
        return;
    }

    const size_t open_brace = source.find(&#39;{&#39;, class_pos);
    if (open_brace == std::string::npos)
    {
        return;
    }
    const size_t close_brace = find_matching_brace(source, open_brace);
    if (close_brace == std::string::npos)
    {
        return;
    }

    std::string class_body = source.substr(open_brace + 1, close_brace - open_brace - 1);
    if (class_body.find(&quot;static &quot; + class_name + &quot;&amp; instance(&quot;) != std::string::npos)
    {
        return;
    }

    const std::string singleton_method =
        &quot;\n    static &quot; + class_name + &quot;&amp; instance() {\n&quot;
        &quot;        static &quot; + class_name + &quot; singleton_instance;\n&quot;
        &quot;        return singleton_instance;\n&quot;
        &quot;    }\n&quot;;

    size_t public_pos = class_body.find(&quot;public:&quot;);
    if (public_pos != std::string::npos)
    {
        class_body.insert(public_pos + std::string(&quot;public:&quot;).size(), singleton_method);
    }
    else
    {
        class_body = &quot;\npublic:&quot; + singleton_method + class_body;
    }

    source.replace(open_brace + 1, close_brace - open_brace - 1, class_body);
}

void rewrite_factory_instantiations(std::string&amp; source, const std::string&amp; class_name)
{
    const std::regex pointer_decl(
        &quot;\\b&quot; + class_name + R&quot;(\s*\*\s*([A-Za-z_][A-Za-z0-9_]*)\s*=\s*new\s+)&quot; + class_name + R&quot;(\s*\([^;{}]*\)\s*;)&quot;);
    source = std::regex_replace(source, pointer_decl, &quot;auto&amp; $1 = &quot; + class_name + &quot;::instance();&quot;);

    const std::regex simple_decl(&quot;\\b&quot; + class_name + R&quot;(\s+([A-Za-z_][A-Za-z0-9_]*)\s*;)&quot;);
    source = std::regex_replace(source, simple_decl, &quot;auto&amp; $1 = &quot; + class_name + &quot;::instance();&quot;);

    const std::regex ctor_decl(&quot;\\b&quot; + class_name + R&quot;(\s+([A-Za-z_][A-Za-z0-9_]*)\s*\([^;{}]*\)\s*;)&quot;);
    source = std::regex_replace(source, ctor_decl, &quot;auto&amp; $1 = &quot; + class_name + &quot;::instance();&quot;);

    // Undo accidental rewrite inside injected singleton accessor.
    const std::regex bad_singleton_line(
        R&quot;(static\s+auto&amp;\s+singleton_instance\s*=\s*)&quot; + class_name + R&quot;(\s*::\s*instance\s*\(\s*\)\s*;)&quot;);
    source = std::regex_replace(source, bad_singleton_line, &quot;static &quot; + class_name + &quot; singleton_instance;&quot;);
}

std::string transform_factory_to_singleton(const std::string&amp; source)
{
    std::string out = source;
    const std::vector&lt;std::string&gt; factory_classes = extract_factory_class_names(out);
    for (const std::string&amp; name : factory_classes)
    {
        inject_singleton_accessor(out, name);
        rewrite_factory_instantiations(out, name);
    }
    return out;
}
} // namespace

std::string generate_base_code_from_source(const std::string&amp; source)
{
    std::ostringstream out;
    out &lt;&lt; &quot;// Generated base code\n&quot;;
    out &lt;&lt; source &lt;&lt; &quot;\n&quot;;
    return out.str();
}

std::string generate_target_code_from_source(
    const std::string&amp; source,
    const std::string&amp; source_pattern,
    const std::string&amp; target_pattern)
{
    std::string transformed = source;
    if (lower(source_pattern) == &quot;factory&quot; &amp;&amp; lower(target_pattern) == &quot;singleton&quot;)
    {
        transformed = transform_factory_to_singleton(source);
    }

    std::ostringstream out;
    out &lt;&lt; &quot;// Generated target code\n&quot;;
    out &lt;&lt; &quot;// source_pattern: &quot; &lt;&lt; source_pattern &lt;&lt; &quot;\n&quot;;
    out &lt;&lt; &quot;// target_pattern: &quot; &lt;&lt; target_pattern &lt;&lt; &quot;\n&quot;;
    out &lt;&lt; transformed &lt;&lt; &quot;\n&quot;;
    return out.str();
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\parse_tree_dependency_utils.cpp ===
#include &quot;parse_tree_dependency_utils.hpp&quot;

#include &quot;parse_tree_symbols.hpp&quot;

#include &lt;utility&gt;

std::vector&lt;DependencySymbolNode&gt; collect_dependency_class_nodes(const ParseTreeNode&amp; root)
{
    rebuild_parse_tree_symbol_tables(root);

    std::vector&lt;DependencySymbolNode&gt; out;
    const std::vector&lt;ParseSymbol&gt;&amp; classes = getClassSymbolTable();
    out.reserve(classes.size());

    for (const ParseSymbol&amp; cls : classes)
    {
        DependencySymbolNode node;
        node.name = cls.name;
        node.signature = cls.signature;
        node.hash_value = cls.hash_value;
        out.push_back(std::move(node));
    }

    return out;
}

std::vector&lt;DependencySymbolNode&gt; collect_dependency_function_nodes(const ParseTreeNode&amp; root)
{
    rebuild_parse_tree_symbol_tables(root);

    std::vector&lt;DependencySymbolNode&gt; out;
    const std::vector&lt;ParseSymbol&gt;&amp; functions = getFunctionSymbolTable();
    out.reserve(functions.size());

    for (const ParseSymbol&amp; fn : functions)
    {
        DependencySymbolNode node;
        node.name = fn.name;
        node.signature = fn.signature;
        node.hash_value = fn.hash_value;
        out.push_back(std::move(node));
    }

    return out;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\parse_tree_symbols.cpp ===
#include &quot;parse_tree_symbols.hpp&quot;
#include &quot;language_tokens.hpp&quot;
#include &quot;lexical_structure_hooks.hpp&quot;

#include &lt;cctype&gt;
#include &lt;functional&gt;
#include &lt;string&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

namespace
{
std::vector&lt;ParseSymbol&gt; g_class_symbols;
std::vector&lt;ParseSymbol&gt; g_function_symbols;
std::vector&lt;ParseSymbolUsage&gt; g_class_usages;
std::unordered_map&lt;std::string, std::vector&lt;size_t&gt;&gt; g_class_name_index;
std::unordered_map&lt;size_t, std::vector&lt;size_t&gt;&gt; g_class_name_hash_index;
std::unordered_map&lt;size_t, size_t&gt; g_class_context_hash_index;
std::unordered_map&lt;std::string, size_t&gt; g_function_index;

std::string trim(const std::string&amp; input)
{
    size_t start = 0;
    while (start &lt; input.size() &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[start])))
    {
        ++start;
    }

    size_t end = input.size();
    while (end &gt; start &amp;&amp; std::isspace(static_cast&lt;unsigned char&gt;(input[end - 1])))
    {
        --end;
    }

    return input.substr(start, end - start);
}

bool starts_with(const std::string&amp; text, const std::string&amp; prefix)
{
    return text.size() &gt;= prefix.size() &amp;&amp; text.compare(0, prefix.size(), prefix) == 0;
}

size_t combine_context_and_token_hash(size_t contextual_hash, const std::string&amp; token)
{
    return std::hash&lt;std::string&gt;{}(std::to_string(contextual_hash) + &quot;|&quot; + token);
}

std::vector&lt;std::string&gt; split_words(const std::string&amp; text)
{
    std::vector&lt;std::string&gt; words;
    std::string current;

    for (char c : text)
    {
        if (std::isalnum(static_cast&lt;unsigned char&gt;(c)) || c == &#39;_&#39;)
        {
            current.push_back(c);
        }
        else if (!current.empty())
        {
            words.push_back(current);
            current.clear();
        }
    }

    if (!current.empty())
    {
        words.push_back(current);
    }

    return words;
}

std::string class_name_from_signature(const std::string&amp; signature)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    const std::vector&lt;std::string&gt; words = split_words(signature);
    for (size_t i = 0; i + 1 &lt; words.size(); ++i)
    {
        const std::string kw = lowercase_ascii(words[i]);
        if (cfg.class_keywords.find(kw) != cfg.class_keywords.end())
        {
            return words[i + 1];
        }
    }

    return {};
}

std::string function_name_from_signature(const std::string&amp; signature)
{
    const std::string trimmed = trim(signature);
    const size_t open = trimmed.find(&#39;(&#39;);
    if (open == std::string::npos)
    {
        return {};
    }

    const std::string left = trim(trimmed.substr(0, open));
    const std::vector&lt;std::string&gt; words = split_words(left);
    if (words.empty())
    {
        return {};
    }

    return words.back();
}

bool is_main_function_name(const std::string&amp; name)
{
    return lowercase_ascii(name) == &quot;main&quot;;
}

bool is_class_block(const ParseTreeNode&amp; node)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string lowered = lowercase_ascii(trim(node.value));
    for (const std::string&amp; kw : cfg.class_keywords)
    {
        if (starts_with(lowered, kw + &quot; &quot;))
        {
            return true;
        }
    }

    return false;
}

bool is_function_block(const ParseTreeNode&amp; node)
{
    const LanguageTokenConfig&amp; cfg = language_tokens(LanguageId::Cpp);
    if (node.kind != &quot;Block&quot;)
    {
        return false;
    }

    const std::string signature = trim(node.value);
    if (signature.empty() || signature.find(&#39;(&#39;) == std::string::npos || signature.find(&#39;)&#39;) == std::string::npos)
    {
        return false;
    }

    const std::vector&lt;std::string&gt; words = split_words(signature);
    if (words.empty())
    {
        return false;
    }

    const std::string first_word = lowercase_ascii(words.front());
    if (cfg.function_exclusion_keywords.find(first_word) != cfg.function_exclusion_keywords.end())
    {
        return false;
    }

    const std::string lowered = lowercase_ascii(signature);
    for (const std::string&amp; kw : cfg.function_exclusion_keywords)
    {
        if (starts_with(lowered, kw + &quot; &quot;) || starts_with(lowered, kw + &quot;(&quot;))
        {
            return false;
        }
    }

    return true;
}

void add_class_symbol(
    const std::string&amp; signature,
    size_t definition_node_index,
    size_t node_contextual_hash)
{
    const std::string name = class_name_from_signature(signature);
    if (name.empty())
    {
        return;
    }

    if (g_class_context_hash_index.find(node_contextual_hash) != g_class_context_hash_index.end())
    {
        return;
    }

    ParseSymbol s;
    s.name = name;
    s.signature = signature;
    s.name_hash = std::hash&lt;std::string&gt;{}(name);
    s.contextual_hash = node_contextual_hash;
    s.hash_value = combine_context_and_token_hash(node_contextual_hash, name);
    s.definition_node_index = definition_node_index;

    g_class_name_index[name].push_back(g_class_symbols.size());
    g_class_name_hash_index[s.name_hash].push_back(g_class_symbols.size());
    g_class_context_hash_index[s.contextual_hash] = g_class_symbols.size();
    g_class_symbols.push_back(std::move(s));
}

void add_function_symbol(const std::string&amp; signature, size_t node_contextual_hash)
{
    const std::string name = function_name_from_signature(signature);
    if (name.empty() || is_main_function_name(name))
    {
        return;
    }

    if (g_function_index.find(name) != g_function_index.end())
    {
        return;
    }

    ParseSymbol s;
    s.name = name;
    s.signature = signature;
    s.name_hash = std::hash&lt;std::string&gt;{}(name);
    s.contextual_hash = node_contextual_hash;
    s.hash_value = combine_context_and_token_hash(node_contextual_hash, name);
    s.definition_node_index = 0;

    g_function_index[name] = g_function_symbols.size();
    g_function_symbols.push_back(std::move(s));
}

void collect_symbols_dfs(const ParseTreeNode&amp; node, size_t&amp; node_index)
{
    ++node_index;

    if (node.kind == &quot;ClassDecl&quot; || node.kind == &quot;StructDecl&quot; || is_class_block(node))
    {
        add_class_symbol(node.value, node_index, node.contextual_hash);
    }

    if (is_function_block(node))
    {
        add_function_symbol(node.value, node.contextual_hash);
    }

    for (const ParseTreeNode&amp; child : node.children)
    {
        collect_symbols_dfs(child, node_index);
    }
}

bool is_candidate_usage_node(const ParseTreeNode&amp; node)
{
    return !node.value.empty() &amp;&amp;
           node.kind != &quot;IncludeDependency&quot; &amp;&amp;
           node.kind != &quot;SymbolDependency&quot;;
}

void collect_class_usages_dfs(const ParseTreeNode&amp; node, size_t&amp; node_index)
{
    ++node_index;

    const bool declaration_node =
        (node.kind == &quot;ClassDecl&quot; || node.kind == &quot;StructDecl&quot; || is_class_block(node));

    if (is_candidate_usage_node(node))
    {
        const std::vector&lt;std::string&gt; words = split_words(node.value);
        for (const std::string&amp; word : words)
        {
            const size_t class_name_hash = std::hash&lt;std::string&gt;{}(word);
            const auto hit = g_class_name_hash_index.find(class_name_hash);
            if (hit != g_class_name_hash_index.end())
            {
                size_t exact_name_matches = 0;
                bool exact_name_match = false;
                for (size_t class_idx : hit-&gt;second)
                {
                    if (class_idx &lt; g_class_symbols.size() &amp;&amp; g_class_symbols[class_idx].name == word)
                    {
                        ++exact_name_matches;
                        exact_name_match = true;
                    }
                }

                const bool hash_collision = !exact_name_match || hit-&gt;second.size() &gt; exact_name_matches;
                if (!(declaration_node &amp;&amp; class_name_from_signature(node.value) == word))
                {
                    ParseSymbolUsage usage;
                    usage.name = word;
                    usage.type_string = word;
                    usage.node_kind = node.kind;
                    usage.node_value = node.value;
                    usage.node_index = node_index;
                    usage.node_contextual_hash = node.contextual_hash;
                    usage.class_name_hash = class_name_hash;
                    usage.hash_value = combine_context_and_token_hash(node.contextual_hash, word);
                    usage.refactor_candidate = is_crucial_class_name(word);
                    usage.hash_collision = hash_collision;
                    g_class_usages.push_back(std::move(usage));
                }
            }
        }
    }

    for (const ParseTreeNode&amp; child : node.children)
    {
        collect_class_usages_dfs(child, node_index);
    }
}

std::string extract_return_candidate_name(const std::string&amp; return_expression)
{
    std::string expr = trim(return_expression);
    std::string lowered = lowercase_ascii(expr);

    if (starts_with(lowered, &quot;return&quot;))
    {
        expr = trim(expr.substr(6));
        lowered = lowercase_ascii(expr);
    }

    if (starts_with(lowered, &quot;new &quot;))
    {
        expr = trim(expr.substr(4));
    }

    const std::vector&lt;std::string&gt; words = split_words(expr);
    if (words.empty())
    {
        return {};
    }

    return words.front();
}
} // namespace

void rebuild_parse_tree_symbol_tables(const ParseTreeNode&amp; root)
{
    g_class_symbols.clear();
    g_function_symbols.clear();
    g_class_usages.clear();
    g_class_name_index.clear();
    g_class_name_hash_index.clear();
    g_class_context_hash_index.clear();
    g_function_index.clear();

    size_t definition_node_index = 0;
    collect_symbols_dfs(root, definition_node_index);

    size_t usage_node_index = 0;
    collect_class_usages_dfs(root, usage_node_index);
}

const std::vector&lt;ParseSymbol&gt;&amp; getClassSymbolTable()
{
    return g_class_symbols;
}

const std::vector&lt;ParseSymbol&gt;&amp; getFunctionSymbolTable()
{
    return g_function_symbols;
}

const std::vector&lt;ParseSymbolUsage&gt;&amp; getClassUsageTable()
{
    return g_class_usages;
}

const ParseSymbol* getClassByName(const std::string&amp; name)
{
    const auto it = g_class_name_index.find(name);
    if (it == g_class_name_index.end() || it-&gt;second.empty())
    {
        return nullptr;
    }

    return &amp;g_class_symbols[it-&gt;second.front()];
}

const ParseSymbol* getClassByHash(size_t hash_value)
{
    const auto context_it = g_class_context_hash_index.find(hash_value);
    if (context_it != g_class_context_hash_index.end())
    {
        return &amp;g_class_symbols[context_it-&gt;second];
    }

    const auto name_hash_it = g_class_name_hash_index.find(hash_value);
    if (name_hash_it == g_class_name_hash_index.end() || name_hash_it-&gt;second.empty())
    {
        return nullptr;
    }

    return &amp;g_class_symbols[name_hash_it-&gt;second.front()];
}

const ParseSymbol* getFunctionByName(const std::string&amp; name)
{
    const auto it = g_function_index.find(name);
    if (it == g_function_index.end())
    {
        return nullptr;
    }

    return &amp;g_function_symbols[it-&gt;second];
}

std::vector&lt;ParseSymbolUsage&gt; getClassUsagesByName(const std::string&amp; name)
{
    std::vector&lt;ParseSymbolUsage&gt; out;
    for (const ParseSymbolUsage&amp; usage : g_class_usages)
    {
        if (usage.name == name)
        {
            out.push_back(usage);
        }
    }
    return out;
}

bool returnTargetsKnownClass(const std::string&amp; return_expression)
{
    const std::string candidate = extract_return_candidate_name(return_expression);
    if (candidate.empty())
    {
        return false;
    }

    return getClassByName(candidate) != nullptr;
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\source_reader.cpp ===
#include &quot;source_reader.hpp&quot;

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;

std::vector&lt;SourceFileUnit&gt; read_source_file_units(const std::vector&lt;std::string&gt;&amp; files)
{
    if (files.empty())
    {
        return {};
    }

    std::vector&lt;SourceFileUnit&gt; units;
    units.reserve(files.size());

    for (const std::string&amp; path : files)
    {
        std::ifstream file(path);
        if (!file)
        {
            std::cerr &lt;&lt; &quot;Failed to open &quot; &lt;&lt; path &lt;&lt; &#39;\n&#39;;
            return {};
        }

        SourceFileUnit unit;
        unit.path = path;
        std::ostringstream buffer;
        buffer &lt;&lt; file.rdbuf();
        unit.content = buffer.str();
        units.push_back(std::move(unit));
    }

    return units;
}

std::string join_source_file_units(const std::vector&lt;SourceFileUnit&gt;&amp; units)
{
    std::ostringstream merged;
    for (size_t i = 0; i &lt; units.size(); ++i)
    {
        merged &lt;&lt; &quot;\n// === FILE: &quot; &lt;&lt; units[i].path &lt;&lt; &quot; ===\n&quot;;
        merged &lt;&lt; units[i].content;
        if (i + 1 &lt; units.size())
        {
            merged &lt;&lt; &#39;\n&#39;;
        }
    }
    return merged.str();
}


// === FILE: .\Project\Modules\Source\SyntacticBrokenAST\tree_html_renderer.cpp ===
#include &quot;tree_html_renderer.hpp&quot;

#include &lt;sstream&gt;

namespace
{
std::string escape_html(const std::string&amp; input)
{
    std::string out;
    out.reserve(input.size());

    for (char c : input)
    {
        switch (c)
        {
            case &#39;&amp;&#39;: out += &quot;&amp;amp;&quot;; break;
            case &#39;&lt;&#39;: out += &quot;&amp;lt;&quot;; break;
            case &#39;&gt;&#39;: out += &quot;&amp;gt;&quot;; break;
            case &#39;&quot;&#39;: out += &quot;&amp;quot;&quot;; break;
            case &#39;\&#39;&#39;: out += &quot;&amp;#39;&quot;; break;
            default: out.push_back(c); break;
        }
    }

    return out;
}

void write_node_html(std::ostringstream&amp; out, const ParseTreeNode&amp; node)
{
    out &lt;&lt; &quot;&lt;li&gt;&lt;span class=\&quot;kind\&quot;&gt;&quot; &lt;&lt; escape_html(node.kind) &lt;&lt; &quot;&lt;/span&gt;&quot;;
    const std::string&amp; display_value = node.annotated_value.empty() ? node.value : node.annotated_value;
    if (!display_value.empty())
    {
        out &lt;&lt; &quot; &lt;span class=\&quot;value\&quot;&gt;&quot; &lt;&lt; escape_html(display_value) &lt;&lt; &quot;&lt;/span&gt;&quot;;
    }
    out &lt;&lt; &quot; &lt;span class=\&quot;meta\&quot;&gt;ctx=&quot; &lt;&lt; node.contextual_hash &lt;&lt; &quot;&lt;/span&gt;&quot;;

    if (!node.children.empty())
    {
        out &lt;&lt; &quot;&lt;ul&gt;&quot;;
        for (const ParseTreeNode&amp; child : node.children)
        {
            write_node_html(out, child);
        }
        out &lt;&lt; &quot;&lt;/ul&gt;&quot;;
    }

    out &lt;&lt; &quot;&lt;/li&gt;&quot;;
}
} // namespace

std::string render_tree_html(
    const ParseTreeNode&amp; root,
    const std::string&amp; title,
    const std::string&amp; empty_message)
{
    std::ostringstream out;

    out &lt;&lt; &quot;&lt;!doctype html&gt;\n&quot;;
    out &lt;&lt; &quot;&lt;html lang=\&quot;en\&quot;&gt;\n&quot;;
    out &lt;&lt; &quot;&lt;head&gt;\n&quot;;
    out &lt;&lt; &quot;  &lt;meta charset=\&quot;utf-8\&quot;&gt;\n&quot;;
    out &lt;&lt; &quot;  &lt;meta name=\&quot;viewport\&quot; content=\&quot;width=device-width, initial-scale=1\&quot;&gt;\n&quot;;
    out &lt;&lt; &quot;  &lt;title&gt;&quot; &lt;&lt; escape_html(title) &lt;&lt; &quot;&lt;/title&gt;\n&quot;;
    out &lt;&lt; &quot;  &lt;style&gt;\n&quot;;
    out &lt;&lt; &quot;    body { font-family: Segoe UI, sans-serif; margin: 24px; background: #f8fbff; color: #1f2937; }\n&quot;;
    out &lt;&lt; &quot;    h1 { margin: 0 0 12px; font-size: 1.15rem; }\n&quot;;
    out &lt;&lt; &quot;    p { margin: 0; color: #475569; }\n&quot;;
    out &lt;&lt; &quot;    ul { list-style: none; margin: 0; padding-left: 1.1rem; border-left: 1px solid #d1d5db; }\n&quot;;
    out &lt;&lt; &quot;    li { margin: 0.35rem 0; }\n&quot;;
    out &lt;&lt; &quot;    .kind { font-weight: 700; color: #0f172a; }\n&quot;;
    out &lt;&lt; &quot;    .value { color: #334155; }\n&quot;;
    out &lt;&lt; &quot;    .meta { color: #64748b; font-size: 0.85em; }\n&quot;;
    out &lt;&lt; &quot;  &lt;/style&gt;\n&quot;;
    out &lt;&lt; &quot;&lt;/head&gt;\n&quot;;
    out &lt;&lt; &quot;&lt;body&gt;\n&quot;;
    out &lt;&lt; &quot;  &lt;h1&gt;&quot; &lt;&lt; escape_html(title) &lt;&lt; &quot;&lt;/h1&gt;\n&quot;;

    if (root.children.empty())
    {
        out &lt;&lt; &quot;  &lt;p&gt;&quot; &lt;&lt; escape_html(empty_message) &lt;&lt; &quot;&lt;/p&gt;\n&quot;;
    }
    else
    {
        out &lt;&lt; &quot;  &lt;ul&gt;&quot;;
        write_node_html(out, root);
        out &lt;&lt; &quot;&lt;/ul&gt;\n&quot;;
    }

    out &lt;&lt; &quot;&lt;/body&gt;\n&quot;;
    out &lt;&lt; &quot;&lt;/html&gt;\n&quot;;

    return out.str();
}


// === FILE: .\Project\Test\test_source.cpp ===


// === FILE: .\Project\Test\Input\domain_models_source.cpp ===
// Additional non-pattern context classes.
// These should not be treated as creational pattern targets.

#include &lt;string&gt;

class Driver {
public:
    std::string license_id;
};

class FleetVehicle {
public:
    std::string plate_number;
};

class Trip {
public:
    Driver driver;
    FleetVehicle vehicle;
};


// === FILE: .\Project\Test\Input\factory_to_singleton_source.cpp ===
// Sample input for CLI analysis:
// source_pattern=factory target_pattern=singleton

#include &lt;memory&gt;
#include &lt;string&gt;

class Person {
public:
    explicit Person(std::string n) : name(std::move(n)) {}
    std::string name;
};

class Vehicle {
public:
    explicit Vehicle(std::string b) : brand(std::move(b)) {}
    std::string brand;
};

class Report {
public:
    std::string format;
};

class CsvReport : public Report {
public:
    CsvReport() { format = &quot;csv&quot;; }
};

class JsonReport : public Report {
public:
    JsonReport() { format = &quot;json&quot;; }
};

class ReportFactory {
public:
    std::unique_ptr&lt;Report&gt; create(int kind) {
        if (kind == 0) {
            return std::make_unique&lt;CsvReport&gt;();
        }
        return std::make_unique&lt;JsonReport&gt;();
    }
};

class AppConfig {
public:
    static AppConfig get() {
        static AppConfig instance;
        return instance;
    }

    bool debug = true;
};

int main() {
    ReportFactory factory;
    std::unique_ptr&lt;Report&gt; report = factory.create(1);

    AppConfig cfg = AppConfig::get();
    if (cfg.debug &amp;&amp; report) {
        return 0;
    }
    return 1;
}

</pre>
</body>
</html>
